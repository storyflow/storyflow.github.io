<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Smart原则</title>
    <link href="/2021/08/12/Smart%E5%8E%9F%E5%88%99/"/>
    <url>/2021/08/12/Smart%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>SMART原则</strong>是目标管理中的一种方法。</p><p>SMART原则中的“S”、“M”、“A”、“R”、“T”五个字母分别对应了五个英文单词：Specific（明确）、Measurable（可衡量）、Achievable（可达成）、Relevant（相关）和Time-bound（有时限）。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>目标：增加APP日活</p><p><strong>S</strong>pecific: 增加留存5%</p><p><strong>M</strong>easurable: 策略标准，怎么定量分析，比如统计后台可以看到</p><p><strong>A</strong>chievable: 是可以完成的，和相应的执行人员达成共识</p><p><strong>R</strong>elevant: 和月度目标是要有关联的</p><p><strong>T</strong>ime-bound: 月底要完成</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1、一个好的目标需要具备什么条件？<br><strong>目标的本质是制造张力，计划的本质就是控制</strong></p><p>2、阻碍目标达成的因素是什么？</p><p>一般是没想清楚，导致比预期的复杂</p><p>3、能否更具挑战性？</p><p>多想一步是更好的</p><p>4、是否致力于设定一个能促进成长的目标？</p><p>短期目标还是为了长期目标服务的</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1、拆分的不够细，一个子任务占比超过50%显然是不对的。</p><p>可以按步骤，分多期来处理，正常单个子任务权重不超过30%。</p><p>2、目标发生了变化, 意味着工作重点发生了变化</p><p>3、月度可以根据目标达成结果进行改善</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>韭菜的自我修养</title>
    <link href="/2021/08/12/%E9%9F%AD%E8%8F%9C%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    <url>/2021/08/12/%E9%9F%AD%E8%8F%9C%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    
    <content type="html"><![CDATA[<p>你是一个韭菜，你从来都是韭菜。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>故事来源：dianping的霸王餐，中了上海热门榜第一（网红）的霸王餐，然后排队很久，反套路商家，被收买的故事。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>商家先用东西来吸引你，可能是钱，可能是免费，反正是你需要的东西。</p><p>吸引来了之后，或通过饥饿营销，或通过其他骚操作，来吸引你投入。</p><p>老板想要啥，当然是我的时间和注意力了。</p><p>有的人发现被耍了之后，就不玩了，或者不参与了，我不当韭菜。</p><p>有的人发现之后，被收买了，然后也不会去叫醒其他人。</p><p>有的人发现之后，来对抗这种行为，这种人我是相当佩服。</p><p>大部分人，不愿意放弃沉默成本，被成功收割。</p><p>商业模式（比如网赚等等），很多是通过各种骚操作来吸引注意力，然后来集中收割。</p><p>对于韭菜而言，被谁收割都是收割。</p><h2 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h2><p>韭菜会追求所谓的公平，公平的排队？还是公平的面试？公平的参与？</p><p>你以为的公平，只是你认为的公平。</p><p>你认为的公平就是真正的公平吗？</p><h2 id="韭菜的自我修养"><a href="#韭菜的自我修养" class="headerlink" title="韭菜的自我修养"></a>韭菜的自我修养</h2><p>1、活成一只好韭菜</p><p>2、管中窥豹，可见一斑。</p><p>你可能在乎收益，可能别人在乎你的本金。</p><p>在乎短期的利益，注定是个有弱点的韭菜。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Xdebug进行远程调试</title>
    <link href="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"/>
    <url>/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><ol><li>方便联调：<br> 和客户端一起联调，是die(); exit(); 会影响其他人员是使用。</li><li>关注数据变化：<br> 正常情况下，我们在调试和开发时，更关注数据的变化。频繁断点、效率比较低。</li><li>简单：<br> 之前的开发自己比较懒，一直没用，用起来发现很简单。<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>运行xdebug需要客户端IDE（phpstorm）、远程服务器配合，首先是客户端配置好端口，发送debug请求，请求会通过浏览器或者IDE的http请求，携带特定的参数发送到服务端，服务端收到请求后，发现这是一个xdebug请求，则与IDE建立dpgp连接，当遇到断点时候，返回调试信息给IDE</li></ol><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/dbgp-setup2.gif" alt="image | left"></p><ul><li>服务器的IP是10.0.1.2，端口80上有HTTP</li><li>IDE位于未知IP上，因此<a href="https://xdebug.org/docs/all_settings#remote_connect_back">xdebug.remote_connect_back</a>设置为1</li><li>IDE侦听端口9000，因此<a href="https://xdebug.org/docs/all_settings#remote_port">xdebug.remote_port</a>设置为9000</li><li>发出HTTP请求，Xdebug从HTTP头中检测IP地址</li><li>Xdebug连接到端口9000上检测到的IP（10.0.1.42）</li><li>调试运行，提供HTTP响应</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536630028850-6b8b1d43-596f-41b0-8f3c-4fca581ed938.png" alt="7c8bad15595a7ed97230e075124cb9ff.png | center | 827x436"></p><h3 id="1-安装xdebug扩展"><a href="#1-安装xdebug扩展" class="headerlink" title="1. 安装xdebug扩展"></a>1. 安装xdebug扩展</h3><p><a href="https://xdebug.org/download.php">https://xdebug.org/download.php</a></p><h3 id="2-远程环境配置"><a href="#2-远程环境配置" class="headerlink" title="2. 远程环境配置"></a>2. 远程环境配置</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">zend_extension=xdebug<span class="hljs-selector-class">.so</span><br>xdebug.idekey=PHPSTORM<br>xdebug<span class="hljs-selector-class">.remote_connect_back</span> = <span class="hljs-number">1</span><br><span class="hljs-comment">//如果开启此，将忽略下面的 xdebug.remote_host 的参数</span><br><br>xdebug.remote_host=<span class="hljs-number">192.168</span><span class="hljs-selector-class">.x</span><span class="hljs-selector-class">.x</span><br><span class="hljs-comment">//注意这里是，客户端的ip&lt;即IDE的机器的ip,不是你的web server&gt;</span><br><br>xdebug.remote_enable=on<br>xdebug<span class="hljs-selector-class">.remote_port</span> = <span class="hljs-number">9001</span><br><span class="hljs-comment">//注意这里是，客户端的端口&lt;即IDE的机器的ip,不是你的web server&gt;</span><br><br>xdebug<span class="hljs-selector-class">.remote_handler</span> = dbgp<br>xdebug<span class="hljs-selector-class">.auto_trace</span> = <span class="hljs-number">1</span><br>xdebug<span class="hljs-selector-class">.remote_log</span> = /tmp/xdebug.log<br></code></pre></td></tr></table></figure><h3 id="3-配置deployment"><a href="#3-配置deployment" class="headerlink" title="3. 配置deployment"></a>3. 配置deployment</h3><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536630853918-79a6fc79-8219-4065-9fcb-ed54408f97b8.jpeg" alt="v2-169647ab9bc2bf755f572ef4b0ff4116_hd.jpg | center | 720x641"></p><h3 id="4-Phpstorm-Debug配置"><a href="#4-Phpstorm-Debug配置" class="headerlink" title="4. Phpstorm Debug配置"></a>4. Phpstorm Debug配置</h3><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536630313482-89d021c9-e4c2-47db-b321-dce8a8e450d8.png" alt="企业微信截图_153663027822.png | center | 827x571"></p><h3 id="5-开启phpstorm-数据监听"><a href="#5-开启phpstorm-数据监听" class="headerlink" title="5. 开启phpstorm 数据监听"></a>5. 开启phpstorm 数据监听</h3><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536630767918-66fe3bd7-36da-41c0-aefc-2139a35269ec.png" alt="企业微信截图_15366307559249.png | center | 446x79"></p><h3 id="6-设置-debug-session"><a href="#6-设置-debug-session" class="headerlink" title="6. 设置 debug session"></a>6. 设置 debug session</h3><p>debug session 的工具的目的是设置一个cookie, 让每次发送数据的时候都会携带这个 cookie, 从而识别监听.</p><p>6.1) 安装工具<br><a href="https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc">https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc</a></p><p>6.2) 点击图标设置</p><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536631091957-8c6806b0-29ec-4aeb-8f50-687a51d3ad1b.png" alt="企业微信截图_15366310693718.png | center | 202x226"></p><p>6.3） 已经设置了cookie, Key 是 <code>XDEBUG_SESSION</code>, 值是 <code>PHPSTORM</code></p><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536631205993-bd06e1ff-f9c7-4d1e-8edd-b0cc1592775b.png" alt="企业微信截图_153663027822.png | center | 824x446"></p><h3 id="7-运行页面"><a href="#7-运行页面" class="headerlink" title="7. 运行页面"></a>7. 运行页面</h3><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536631295449-4fe998cf-8812-402b-980f-790e90df4c87.png" alt="企业微信截图_15365753413668.png | center | 622x234"></p><h2 id="其他调试方式"><a href="#其他调试方式" class="headerlink" title="其他调试方式"></a>其他调试方式</h2><p>上面的模式有个缺点，插件是针对于一个标签页<br>快捷键：<br>Mac: Ctrl+Shift+X Windows:Alt+Shift+X</p><h3 id="内部模式"><a href="#内部模式" class="headerlink" title="内部模式"></a>内部模式</h3><h4 id="1-设置-web-访问的服务器"><a href="#1-设置-web-访问的服务器" class="headerlink" title="1. 设置 web 访问的服务器"></a><strong>1. 设置 web 访问的服务器</strong></h4><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536632468788-c06b4fd9-c68a-4210-99a9-731b892bb497.png" alt="企业微信截图_15366324012641.png | center | 827x571"></p><h4 id="2-配置调试页面"><a href="#2-配置调试页面" class="headerlink" title="2. 配置调试页面"></a>2. 配置调试页面</h4><p>我们这里创建的调试页面的类型是<code>PHP Web Page</code>, 服务器选择的是刚才已经建立好的服务器</p><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536632586232-8de4ff11-7bea-4595-b0ff-d95a0ffa8d7d.png" alt="企业微信截图_15366324012641.png | center | 827x554"></p><h4 id="3-运行测试页面"><a href="#3-运行测试页面" class="headerlink" title="3. 运行测试页面"></a>3. 运行测试页面</h4><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536632899220-90af138c-2aa7-47d2-a3f9-9167f76b37c8.png" alt="企业微信截图_15366324012641.png | center | 287x97"></p><p>自动生成：XDEBUG_SESSION_START<br><a href="http://example.com/?XDEBUG_SESSION_START=13608">http://example.com/?XDEBUG_SESSION_START=13608</a></p><h3 id="Fiddler工具调试"><a href="#Fiddler工具调试" class="headerlink" title="Fiddler工具调试"></a>Fiddler工具调试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">if (oSession.host == &quot;xxxx&quot;)<br>&#123;<br>var sCookie = oSession.oRequest[&quot;Cookie&quot;] + &#x27;;XDEBUG_SESSION=PHPSTORM;&#x27;;<br>oSession.oRequest.headers.Add(&quot;Cookie&quot;, sCookie);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">export XDEBUG_CONFIG=&quot;idekey=PHPSTORM&quot;<br>php myscript.php<br></code></pre></td></tr></table></figure><h3 id="多人开发模式"><a href="#多人开发模式" class="headerlink" title="多人开发模式"></a>多人开发模式</h3><p><a href="https://derickrethans.nl/debugging-with-multiple-users.html">https://derickrethans.nl/debugging-with-multiple-users.html</a><br>插件下载地址：<a href="http://code.activestate.com/komodo/remotedebugging/">http://code.activestate.com/komodo/remotedebugging/</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-查看兼容性"><a href="#1-查看兼容性" class="headerlink" title="1. 查看兼容性"></a>1. 查看兼容性</h3><p>第一次运行的时候可以通过 phpstorm 自带的工具来检查配置的兼容性.<br><code>Run &gt; Web Server Debug Validation</code><br>校验代码<br>：<a href="https://gist.github.com/han8gui/231ba75c8989ffe6dfab3831c0dcd58a">https://gist.github.com/han8gui/231ba75c8989ffe6dfab3831c0dcd58a</a></p><h3 id="2-debug-帮助面板说明"><a href="#2-debug-帮助面板说明" class="headerlink" title="2. debug 帮助面板说明"></a>2. debug 帮助面板说明</h3><p><img src="/2018/09/12/%E4%BD%BF%E7%94%A8Xdebug%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/1536633142576-1e57ddb6-6068-468c-a778-cf6f901e6bea.png" alt="2cd9bf236c0d2ef6f143943fe82c240a.png | center | 827x201"></p><p><strong>左侧</strong><br>绿色三角形 ： <code>Resume Program</code>，表示將继续执行，直到下一个中断点停止。<br>红色方形 ： <code>Stop</code>，表示中断当前程序调试。</p><p><strong>上方</strong><br>第一个图形示 ： <code>Step Over</code>，跳过当前函数。<br>第二个图形示 ： <code>Step Into</code>，进入当前函数內部的程序（相当于观察程序一步一步执行）。<br>第三个图形示 ： <code>Force Step Into</code>，強制进入当前函数內部的程序。<br>第四个图形示 ： <code>Step Out</code>，跳出当前函数內部的程式。<br>第五个图形示 ： <code>Run to Cursor</code>，定位到当前光标。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://segmentfault.com/a/1190000011387666">https://segmentfault.com/a/1190000011387666</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vue入门</title>
    <link href="/2018/05/15/vue%E5%85%A5%E9%97%A8/"/>
    <url>/2018/05/15/vue%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为什么要用？"><a href="#一、为什么要用？" class="headerlink" title="一、为什么要用？"></a>一、为什么要用？</h2><ol><li>之前基本上用的是jQuery，jQuery基于DOM操作，MVVM的开发模式也使前端从原先的DOM操作中解放出来，我们不再需要在维护视图和数据的统一上花大量的时间，只需要关注于data的变化，代码变得更加容易维护。</li><li>组件：复用性高，容易维护，方便测试，高内聚，低耦。</li></ol><h2 id="二、什么是MVVM"><a href="#二、什么是MVVM" class="headerlink" title="二、什么是MVVM?"></a>二、什么是MVVM?</h2><p><img src="/2018/05/15/vue%E5%85%A5%E9%97%A8/1525846625786-82246360-effb-4a2c-afd1-8a97fecfb86b.png" alt="bg2015020110.png | left | 552x420"></p><p>双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p><strong>数据劫持:</strong><span data-type="color" style="color: rgb(36, 41, 46);"><span data-type="background" style="background-color: rgb(255, 255, 255);">&nbsp;</span></span>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code><span data-type="color" style="color: rgb(36, 41, 46);"><span data-type="background" style="background-color: rgb(255, 255, 255);">来劫持各个属性的</span></span><code>setter</code><span data-type="color" style="color: rgb(36, 41, 46);"><span data-type="background" style="background-color: rgb(255, 255, 255);">，</span></span><code>getter</code><span data-type="color" style="color: rgb(36, 41, 46);"><span data-type="background" style="background-color: rgb(255, 255, 255);">，在数据变动时发布消息给订阅者，触发相应的监听回调。</span></span></p><p><img src="/2018/05/15/vue%E5%85%A5%E9%97%A8/1525847691363-be00a668-39ec-4c11-b731-ccb28b54fb9c.png" alt="image.png | left | 730x390"></p><p>用JavaScript实现 <a href="https://github.com/DMQ/mvvm">https://github.com/DMQ/mvvm</a><br>演示：<a href="http://bing.2345.com/mvvm/mvvm.html">http://bing.2345.com/mvvm/mvvm.html</a> （host: 172.16.0.156 bing.2345.com）</p><h2 id="四、入门"><a href="#四、入门" class="headerlink" title="四、入门"></a>四、入门</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">Vue (读音 /vjuː/，类似于&nbsp;</span></span><strong>view</strong><span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">) 是一套用于构建用户界面的</span></span><strong>渐进式框架</strong><span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</span></span></p><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><p><a href="https://cn.vuejs.org/v2/guide/installation.html">https://cn.vuejs.org/v2/guide/installation.html</a></p><h4 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h4><div class="bi-table"><br>  <table><br>    <colgroup><br>      <col width="90px"><br>    </colgroup><br>    <tbody><br>      <tr><br>        <td rowspan="1" colspan="1"><pre><code class="language-undefined">&lt;script src=”<a href="https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script">https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js&quot;&gt;&lt;/script</a>&gt;<br></code></pre></td><br>      </tr><br>    </tbody><br>  </table><br></div><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 不推荐上来就直接用 vue-cli 构建项目，尤其是如果没有 Node/Webpack 基础。</span><br><br><span class="hljs-comment"># 使用淘宝镜像</span><br>npm install -g cnpm --registry=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 全局安装 vue-cli</span><br>$ npm install --global vue-cli<br><br><span class="hljs-comment"># 创建一个基于 webpack 模板的新项目</span><br>$ vue init webpack my-project<br><br>安装依赖，走你<br>$ <span class="hljs-built_in">cd</span> my-project<br>$ npm run dev<br></code></pre></td></tr></table></figure><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ol><li><a href="https://github.com/vuejs/vue-devtools">https://github.com/vuejs/vue-devtools</a></li></ol><h2 id="五、示例"><a href="#五、示例" class="headerlink" title="五、示例"></a>五、示例</h2><p>文档（作者是中国人） + <span data-type="color" style="color: rgb(26, 26, 26);"><span data-type="background" style="background-color: rgb(255, 255, 255);">官网上的示例 + 自己练习（推荐jsfiddle）</span></span><br>主要了解：<span data-type="color" style="color: rgb(26, 26, 26);"><span data-type="background" style="background-color: rgb(255, 255, 255);">响应式机制 + 组件</span></span></p><p>Hello World：<a href="https://jsfiddle.net/han8gui/nnc957z4/10/">https://jsfiddle.net/han8gui/nnc957z4/10/</a><br>Form：<a href="https://jsfiddle.net/han8gui/g072h4x6/">https://jsfiddle.net/han8gui/g072h4x6/</a><br>ToDoList： <a href="https://jsfiddle.net/han8gui/r42pngbu/6/">https://jsfiddle.net/han8gui/r42pngbu/6/</a></p><h2 id="六、组件"><a href="#六、组件" class="headerlink" title="六、组件"></a>六、组件</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>软件组件<span data-type="color" style="color: rgb(34, 34, 34);"><span data-type="background" style="background-color: rgb(255, 255, 255);">，定义为自包含的、可编程的、可重用的、与语言无关的</span></span>软件<span data-type="color" style="color: rgb(34, 34, 34);"><span data-type="background" style="background-color: rgb(255, 255, 255);">单元。</span></span></p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p><a href="https://jsfiddle.net/han8gui/0c6xszjv/">https://jsfiddle.net/han8gui/0c6xszjv/</a><br>注意：</p><ol><li><p>一个组件的 data 选项必须是一个函数</p></li><li><p>定义组件名的方式有两种：<br> a. 使用 kebab-case<br> 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。<br> b. 使用 PascalCase<br> 当使用 PascalCase (驼峰式命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。</p></li><li><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4></li></ol><p><img src="/2018/05/15/vue%E5%85%A5%E9%97%A8/1525935779079-1d9cea4f-35e0-44ae-a86c-7d6f5f594404.png" alt="20180205153631960.png | center | 826x2093"></p><h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><p><span data-type="color" style="color: rgb(38, 38, 38);"><span data-type="background" style="background-color: rgb(255, 255, 255);">子组件中传递数据：Props</span></span><br>示例: <a href="https://jsfiddle.net/han8gui/hqmgnbhy/">https://jsfiddle.net/han8gui/hqmgnbhy/</a></p><p><span data-type="color" style="color: rgb(38, 38, 38);"><span data-type="background" style="background-color: rgb(255, 255, 255);">子组件</span></span><span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">向父级组件触发一个事件</span></span><br><span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">内建的&nbsp;</span></span><a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6">$emit 方法</a><span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">并传入事件的名字，来向父级组件触发一个事件，</span></span><span data-type="color" style="color: rgb(47, 47, 47);"><span data-type="background" style="background-color: rgb(255, 255, 255);">并传递一个参数</span></span></p><h2 id="七、规模化"><a href="#七、规模化" class="headerlink" title="七、规模化"></a>七、规模化</h2><ol><li>路由 <span data-type="color" style="color: rgb(26, 26, 26);"><span data-type="background" style="background-color: rgb(255, 255, 255);">vue-router</span></span><br> <a href="https://github.com/han8gui/vue-demo">https://github.com/han8gui/vue-demo</a></li><li>状态管理 vuex<br> <span data-type="color" style="color: rgb(52, 73, 94);"><span data-type="background" style="background-color: rgb(255, 255, 255);">记录所有 store 中发生的 state 改变，后面有机会分享下</span></span></li><li>服务端渲染 ssr<br>主要用于SEO<h2 id="八、其他"><a href="#八、其他" class="headerlink" title="八、其他"></a>八、其他</h2></li><li>风格指南：<a href="https://cn.vuejs.org/v2/style-guide/">https://cn.vuejs.org/v2/style-guide/</a></li><li>编码：开发过程中，可以看到bug报错</li><li>Examples: <a href="https://vuejsexamples.com/">https://vuejsexamples.com/</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RESTful入门</title>
    <link href="/2018/03/22/Restful%E5%85%A5%E9%97%A8/"/>
    <url>/2018/03/22/Restful%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Restful入门"><a href="#Restful入门" class="headerlink" title="Restful入门"></a>Restful入门</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ol><li>REpresentational State Transfer的简写 ：表现层状态转移</li><li>理解：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。</li></ol><h2 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h2><ol><li>方便不同的前端设备与后端进行通信</li></ol><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>版本号拼接在 URL<br>api.xxx.com/v1/users<br>另一种做法是，将版本号放在HTTP头信息中。<br>版本号只允许枚举，不允许判断区间。</p><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>一般来说 API 的外在形式无非就是增删改查（当然具体的业务逻辑肯定要复杂得多），而查询又分为详情和列表两种，在 RESTful 中这就相当于通用的模板。例如针对文章（Article）设计 API，那么最基础的 URL 就是这几种：</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h2 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h2><p>GET（SELECT）：从服务器取出资源（一项或多项）。<br>POST（CREATE）：在服务器新建一个资源。<br>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。<br>DELETE（DELETE）：从服务器删除资源。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>GET /zoos：列出所有动物园<br>POST /zoos：新建一个动物园<br>GET /zoos/ID：获取某个指定动物园的信息<br>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）<br>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）<br>DELETE /zoos/ID：删除某个动物园<br>GET /zoos/ID/animals：列出某个指定动物园的所有动物<br>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</p><h2 id="返回值的约束"><a href="#返回值的约束" class="headerlink" title="返回值的约束"></a>返回值的约束</h2><p>GET /collection：返回资源对象的列表（数组）<br>GET /collection/resource：返回单个资源对象<br>POST /collection：返回新生成的资源对象<br>PUT /collection/resource：返回完整的资源对象<br>PATCH /collection/resource：返回完整的资源对象<br>DELETE /collection/resource：返回一个空文档</p><h2 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。<br>下面是一些常见的参数。<br>?limit=10：指定返回记录的数量<br>?offset=10：指定返回记录的开始位置。<br>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。<br>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。<br>?animal_type_id=1：指定筛选条件</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>幂等：调用多次没影响</li><li>特点：面向资源</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">RESTful API 设计指南</a></li><li><a href="http://www.cnblogs.com/xishuai/p/designing-rest-api-uri-query-and-identify.html">RESTful API URI 设计: 查询（Query）和标识（Identify）</a></li><li><a href="https://getkong.org/docs/0.12.x/admin-api/">KONG　Restful</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RESTful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复利</title>
    <link href="/2018/03/07/%E5%A4%8D%E5%88%A9/"/>
    <url>/2018/03/07/%E5%A4%8D%E5%88%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="复利"><a href="#复利" class="headerlink" title="复利"></a>复利</h1><h2 id="单利和复利"><a href="#单利和复利" class="headerlink" title="单利和复利"></a>单利和复利</h2><p>区别：利息是否生息，单利的利息不生息，而复利则是利滚利。<br>单利，每次得到的利息都是相同的，是按最初存入的钱计算出的利息。</p><h2 id="借款"><a href="#借款" class="headerlink" title="借款"></a>借款</h2><p>招商银行：年化 = 日利率 <em> 360<br>蚂蚁花呗: 年化 = 日利率 </em> 365 </p><h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p>复利：本金*(1+利率)^时间</p><h2 id="72法则"><a href="#72法则" class="headerlink" title="72法则"></a>72法则</h2><p>投资金额翻倍实际 = 72 / 年利率 (经验法则)</p><p>假设最初投资金额为100元，复息年利率9%，利用“72法则”，将72除以9（增长率），得8，即需约8年时间，投资金额滚存至200元（两倍于100元），而准确需时为8.0432年。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>目前常见方式：按天计息按月还款</li><li>名义利率和实际利率有啥关系<br>费雪效应：（1+名义利率）=（1+实际利率）X（1+通胀率）</li><li>利率是啥？<br>利率的本质是资金提供方在一段时间内，放弃资金的使用权（拥有资金的所有权），根据资金使用方的信用等综合因素而确定的一个补偿（回报率）<ol start="4"><li>M2 每年增长10%<br>如果你的无风险投资收益率小于这个数字，那么复利的魔力就会让你的实际购买力越来越缩水啦。</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>费率的计算</title>
    <link href="/2018/03/07/%E8%B4%B9%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <url>/2018/03/07/%E8%B4%B9%E7%8E%87%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="费率的计算"><a href="#费率的计算" class="headerlink" title="费率的计算"></a>费率的计算</h1><p>假设贷款总额为m，共分期n期，每期手续费a%，实际年化利率为b%；</p><h2 id="计算："><a href="#计算：" class="headerlink" title="计算："></a>计算：</h2><p>1、从最后一期到第一期，每期实际占用银行资金为1m/n、2m/n、……、nm/n，共n期；<br>2、则总占用银行资金（以月为单位）为m/n + 2m/n + …… + nm/n，为（1+2+ …… +n）m/n，简单的数列求和，化简后为（n+1）m/2;<br>3、n期共还银行利息为 m<em>a%</em>n；<br>4、实际年化利率 b% = amn% / m(n+1) /2 /12，化简后为 b = 24 <em> a </em> n / (n+1)；</p><h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><p>b = 24 <em> a </em> n  /（n+1）<br>b：实际年利率 a：月费率，n：日期。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>拿银行常见分期手续费每期0.6%来算，实际年利率：<br>3期为：  24 <em> 0.6 </em> 3 / 4 = 10.8%;<br>6期为：  24 <em> 0.6 </em> 6 / 7 = 12.34%;<br>12期为：24 <em> 0.6 </em> 12 / 13 = 13.29%;<br>24期为：24 <em> 0.6 </em> 24 / 25 = 13.82%;</p>]]></content>
    
    
    
    <tags>
      
      <tag>费率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>postman入门</title>
    <link href="/2018/02/08/postman%E5%85%A5%E9%97%A8/"/>
    <url>/2018/02/08/postman%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#文档">文档</a></li><li><a href="#常见问题">常见问题</a></li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://www.getpostman.com/">官网</a></li><li><a href="https://www.getpostman.com/docs/">官方文档</a></li><li><a href="https://www.jianshu.com/p/61cfcb436ee4">Postman使用手册4——API test</a></li><li><a href="https://segmentfault.com/a/1190000005055899">基于Postman的API自动化测试</a></li><li><a href="http://blog.csdn.net/zhangying_csu/article/details/52386837">Newman的安装及使用</a></li><li><a href="http://blog.csdn.net/wangjun5159/article/details/47781443">postman中 form-data、x-www-form-urlencoded、raw、binary的区别</a></li><li><a href="http://blog.text.wiki/2017/04/23/postman-collection-and-runner.html">Postman Collection 与 Runner</a></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p>沙箱中如何使用jquery? 如 $.each？<br>说明：jQuery已经不被推荐,取而代之的是cheerio。<br>使用方法：<code>$.each =&gt; _.forEach</code><br><a href="http://blog.getpostman.com/2016/08/30/jquery-replaced-by-cheeriojs-in-postman-sandbox/">官方说明</a><br><a href="https://lodash.com/docs/4.17.5">文档</a></p></li><li><p>postman 设置格式，每次都要手动转换成json？<br>说明：postman 返回格式是auto,会自动识别，但是效果不好，会把json当初字符串来解析。<br>解决办法：在设置更改格式为json</p></li><li><p>postman可以用来做啥？<br>不仅仅可以用来测试接口，还可以做接口自动化测试，生成api文档。</p></li><li><p>runner里执行的时候，一定要注意request的是要保存里的，不然更改了是无效的。send本身是直接起效</p></li><li><p>如何传递数据？<br>键名设置为key[]<br>array[] =&gt; 1<br>array[] =&gt; 2</p></li><li><p>返回的数据有问题，怎么处理？</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">try</span> &#123;<br>    data = <span class="hljs-built_in">JSON</span>.parse(responseBody);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    tests[<span class="hljs-string">&quot;返回错误格式&quot;</span>] = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双显示器问题</title>
    <link href="/2018/02/07/%E5%8F%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2018/02/07/%E5%8F%8C%E6%98%BE%E7%A4%BA%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想换个显示器<br>主机 一个db9串口 和 vga接口<br>刚开始以为买个转换后就好了，最后发现不行</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><table><thead><tr><th>名称</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>db9</td><td style="text-align:left">两排接口</td></tr><tr><td>db15</td><td style="text-align:left">两排接口</td></tr><tr><td>VGA</td><td style="text-align:left">又称 mini db15  三排</td></tr><tr><td>DVI</td><td style="text-align:left">数字视频接口</td></tr><tr><td>HDMI</td><td style="text-align:left">高清晰度多媒体接口</td></tr><tr><td>x针</td><td style="text-align:left">9针 15针  指的 公头</td></tr><tr><td>x孔</td><td style="text-align:left">9孔 15孔 母头</td></tr></tbody></table><p><img src="http://img.blog.csdn.net/20180207225026126" alt="这里写图片描述"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>转接头一般是单向的，要注意方向<br> db15(主机的接口) 转 vga(显示器的口)</li><li>串口不能作为用来接显示器</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Elk 6.1 安装使用说明</title>
    <link href="/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>ELK 不是一款软件，而是 Elasticsearch、Logstash 和 Kibana 三种软件产品的首字母缩写。这三者都是开源软件，通常配合使用，而且又先后归于 Elastic.co 公司名下，所以被简称为 ELK Stack。根据 Google Trend 的信息显示，ELK Stack 已经成为目前最流行的集中式日志解决方案。</p><p><img src="/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/20180112113530006" alt="架构"></p><h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>数据收集引擎：数据存储与数据流。它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置；</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、 <a href="https://www.elastic.co/guide/en/logstash/current/getting-started-with-logstash.html">官方教程</a><br>2、 <a href="https://segmentfault.com/a/1190000010741203">windows下安装Logstash</a></p><p><img src="/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/20180112112615574" alt="效果图"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、windows下需要使用NSSM</p><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>说明：Elastic 需要 Java 8 环境，注意要保证环境变量JAVA_HOME正确设置。<br>1、下载最新Elasticsearch版本，解压到指定目录。<br>2、在Unix上运行bin/elasticsearch或者在Windows上运行bin\elasticsearch.bat<br>3、打开：<a href="http://localhost:9200/">http://localhost:9200/</a> </p><p><img src="/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/20180112112921271" alt="效果图"></p><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol><li>启动内存不足<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># vi $&#123;elasticsearch_HOME&#125;/config/jvm.options</span><br><span class="hljs-meta">#-Xms2g</span><br><span class="hljs-meta">#-Xmx2g</span><br>-Xms512m<br>-Xmx512m<br></code></pre></td></tr></table></figure></li><li>无法以root权限启动<figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># groupadd es</span><br><span class="hljs-meta"># useradd es -g es -p es</span><br><span class="hljs-meta"># chown es:es $&#123;elasticsearch_HOME&#125;/</span><br><span class="hljs-meta"># sudo su es</span><br><span class="hljs-meta"># ./bin/elasticsearch</span><br></code></pre></td></tr></table></figure>安装elasticsearch-head</li></ol><hr><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mobz/</span>elasticsearch-head.git<br>cd elasticsearch-head<br>npm install<br>npm run start<br>open http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9100</span>/<br></code></pre></td></tr></table></figure><p><a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm/">谷歌插件安装链接</a></p><p><img src="/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/20160425113031267" alt="说明"></p><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>Kibana是个数据分析和可视化平台。通常与 Elasticsearch 配合使用，对其中数据进行搜索、分析和以统计图表的方式展示；</p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.elastic.co/guide/en/kibana/6.x/getting-started.html">kibana官方文档</a></p><p><img src="/2018/01/12/Elk-6-1-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/20180112112820144" alt="效果图"></p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、 需要cmd执行，直接运行.bat无效<br>2、 Logstash 6.1.1 issue with setup.bat file “could not find jruby in”<br>在7.0版本修复，下载master文件，并替换bin目录文件接口。</p><p>参考资料</p><ol><li><a href="http://www.cnblogs.com/yiwangzhibujian/p/7137546.html">Kibana入门教程</a></li><li><a href="https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/index.html">Logstash 最佳实践</a></li><li><a href="https://www.elastic.co/guide/en/kibana/6.x/getting-started.html">kibana官方文档</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html">ELK+Filebeat 集中式日志解决方案详解</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>elk elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>502 Bad Gateway 错误排查</title>
    <link href="/2018/01/02/502-Bad-Gateway-%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/"/>
    <url>/2018/01/02/502-Bad-Gateway-%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="含义：连接超时"><a href="#含义：连接超时" class="headerlink" title="含义：连接超时"></a>含义：连接超时</h2><p>我们向服务器器发送请求。由于服务器当前链接太多，导致服务器方面无法给于正常的响应,产生此类报错。</p><p><img src="http://img.blog.csdn.net/20180102115131801?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGltZTg4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="502"></p><h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><p>以php为例</p><p>1、 php</p><ul><li>进程数不够 （max_children最大子进程数）</li><li>最长执行时间（request_terminate_timeout）</li></ul><p>2、 nginx超时<br>nginx.conf里的fastcgi_connect_timeout，fastcgi_send_timeout，fastcgi_read_timeout都调大一点。<br>3、数据库<br>4、代理有问题</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>1、 客户端强制刷新<br>2、 改配置<br>3、 将代理放到CDN上</p><h2 id="补充知识：代理"><a href="#补充知识：代理" class="headerlink" title="补充知识：代理"></a>补充知识：代理</h2><p>代理：代理的核心功能可以用一句话概括：接受客户端的请求，转发到后端服务器，获得应答之后返回给客户端。</p><p><img src="http://img.blog.csdn.net/20180102134723461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGltZTg4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>502 http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php扩展的相关知识</title>
    <link href="/2017/12/26/php%E6%89%A9%E5%B1%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2017/12/26/php%E6%89%A9%E5%B1%95%E7%9A%84%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="yum-install-和-源码安装的区别"><a href="#yum-install-和-源码安装的区别" class="headerlink" title="yum install 和 源码安装的区别"></a>yum install 和 源码安装的区别</h2><p>1，yum安装是将yum源中的rpm包下载到本地，安装这个rpm包。这个rpm包是别人编译安装好的二进制包。这种方式与其说是安装不如说是，更新来的更确切一点。</p><p>2，源码安装，下载是源码包，要进行编译和安装，编译过程，可以进行参数设定。</p><h2 id="如何编译扩展？"><a href="#如何编译扩展？" class="headerlink" title="如何编译扩展？"></a>如何编译扩展？</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> extname<br><span class="hljs-variable">$</span> phpize<br><span class="hljs-variable">$</span> ./configure<br><span class="hljs-variable">$</span> make<br><span class="hljs-comment"># make install</span><br></code></pre></td></tr></table></figure><h2 id="GD库安装"><a href="#GD库安装" class="headerlink" title="GD库安装"></a>GD库安装</h2><p>参考链接：<a href="http://www.nowamagic.net/librarys/veda/detail/2610">http://www.nowamagic.net/librarys/veda/detail/2610</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>扩展</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;E6&gt;&lt;B5&gt;&lt;8B&gt;&lt;E8&gt;&lt;AF&gt;&lt;95&gt;&lt;E5&gt;&lt;86&gt;&lt;85&gt;&lt;E5&gt;&lt;AE&gt;&lt;B9&gt; 是什么编码？</title>
    <link href="/2017/12/26/E6-B5-8B-E8-AF-95-E5-86-85-E5-AE-B9-%E6%98%AF%E4%BB%80%E4%B9%88%E7%BC%96%E7%A0%81%EF%BC%9F/"/>
    <url>/2017/12/26/E6-B5-8B-E8-AF-95-E5-86-85-E5-AE-B9-%E6%98%AF%E4%BB%80%E4%B9%88%E7%BC%96%E7%A0%81%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>一、<code>&lt;E6&gt;&lt;B5&gt;&lt;8B&gt;&lt;E8&gt;&lt;AF&gt;&lt;95&gt;&lt;E5&gt;&lt;86&gt;&lt;85&gt;&lt;E5&gt;&lt;AE&gt;&lt;B9&gt;</code> 是什么编码？</p><p>url(utf-8)编码</p><p>二、 解码方法<br><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt;E6&gt;</span> =&gt; %E6<br><span class="hljs-attribute">&lt;B5&gt;</span> =&gt; %B5<br>以此类推<br><span class="hljs-attribute">&lt;E6&gt;</span><span class="hljs-attribute">&lt;B5&gt;</span><span class="hljs-attribute">&lt;8B&gt;</span><span class="hljs-attribute">&lt;E8&gt;</span><span class="hljs-attribute">&lt;AF&gt;</span><span class="hljs-attribute">&lt;95&gt;</span><span class="hljs-attribute">&lt;E5&gt;</span><span class="hljs-attribute">&lt;86&gt;</span><span class="hljs-attribute">&lt;85&gt;</span><span class="hljs-attribute">&lt;E5&gt;</span><span class="hljs-attribute">&lt;AE&gt;</span><span class="hljs-attribute">&lt;B9&gt;</span><br>=&gt; %E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9<br></code></pre></td></tr></table></figure><br>utf-8转中文就可以了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的使用说明</title>
    <link href="/2017/12/26/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2017/12/26/Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>一、<a href="http://www.runoob.com/redis/redis-install.html">安装教程</a></p><p>二、配置说明<br><img src="https://dn-shimo-image.qbox.me/ZgEKtbJiP8IEbYzJ.png" alt="配置说明"></p><p>三、数据类型</p><p>string：二进制安全的字符串<br>Lists：按插入顺序排序的字符串元素的集合。<br>Sets: 不重复且无序的字符串元素的集合。<br>Sorted sets: 类似Sets,但是每个字符串元素都关联到一个叫score浮动数值（floating number value）。里面的元素总是通过score进行着排序，所以不同的是，它是可以检索的一系列元素<br>Hashes: 由field和关联的value组成的map。field和value都是字符串的</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>一、 redis命令行<br><img src="https://dn-shimo-image.qbox.me/RFCu5Pvvhf0Q7T4E.png" alt="通配符规则"></p><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>一、<a href="http://www.runoob.com/redis/redis-commands.html">Redis命令</a></p><p>二、常用命令</p><p>1、 redis 获取最大的key<br>    ./redis-cli –bigkeys</p><p>三、数据可视化</p><p>1、 phpRedisAdmin</p><h1 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识"></a>进阶知识</h1><h2 id="一、-事务"><a href="#一、-事务" class="headerlink" title="一、 事务"></a>一、 事务</h2><p>场景：转账</p><p><img src="https://dn-shimo-image.qbox.me/caGI80G7Qz04gBnA.png" alt="事务原理"></p><p>语法错误会终止执行<br><img src="https://dn-shimo-image.qbox.me/MgF9Qs2gArQcJAes.png" alt="语法错误"></p><p>备注：redis不支持回滚。</p><p>二、订阅发布</p><p>// todo</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p>1、<a href="http://www.cnblogs.com/stephen-liu74/">Stephen Liu 的redis使用总结</a><br>2、<a href="http://redis.cn">redis中文网</a><br>3、<a href="http://redis.cn/documentation.html">redis中文教程</a><br>3、<a href="http://www.runoob.com/redis/redis-tutorial.html">redis教程</a><br>4、<a href="http://try.redis.io/">实例</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一首小诗</title>
    <link href="/2017/12/24/%E4%B8%80%E9%A6%96%E5%B0%8F%E8%AF%97/"/>
    <url>/2017/12/24/%E4%B8%80%E9%A6%96%E5%B0%8F%E8%AF%97/</url>
    
    <content type="html"><![CDATA[<p>只有友谊还在，<br>热情还可以重来。<br>只有友情还在，<br>绝境就不复存在。<br>只有朋友还在，<br>青春就不会孤单。</p><p>年少轻狂，幸福时光。<br>让最真挚的祝福透过心窗，温暖那遥远的心房。<br>朋友啊，<br>如果看不到明天的太阳，就尽情欣赏今晚的月亮。<br>          —— 2009年 于沭中 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql 如何恢复数据？</title>
    <link href="/2017/12/21/mysql-%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%9F/"/>
    <url>/2017/12/21/mysql-%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>尝试还原数据库，之后提示 table doesn`t exist。</p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>类型：MyISAM<br>数据：Table.frm，Table.MYD，Table.MYI<br>位置：/data/$databasename/目录中<br>说明：直接复制到mysql中data目录中，便可以使用</p><p>类型：InnoDB<br>数据文件：存储在/$innodb_data_home_dir/中的ibdata1文件中<br>结构文件：结构文件存在于/data/table_name.frm中<br>说明：不可以直接使用，并报错：table doesn`t exist</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><p>1、 停止 apache 和 mysql服务<br>2、 拷贝相应文件到/data/目录，在数据库引擎类型为InnoDB时，拷贝数据文件的同时还需要拷贝ibdata1。<br>3、 将根目录下的ib_logfile*文件全部删除掉</p><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><p>1、 正常的数据导出恢复，最好用工具，不要在data文件层面去恢复<br>2、 测试环境在windows下</p><h2 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h2><p>1、 <a href="http://www.cnblogs.com/joeylee/archive/2012/09/27/2705685.html">mysql 直接从date 文件夹备份表，还原数据库之后提示 table doesn`t exist的原因和解决方法</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql 数据恢复</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个角度谈母婴电商的线下模式</title>
    <link href="/2017/12/04/%E4%B8%80%E4%B8%AA%E8%A7%92%E5%BA%A6%E8%B0%88%E6%AF%8D%E5%A9%B4%E7%94%B5%E5%95%86%E7%9A%84%E7%BA%BF%E4%B8%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2017/12/04/%E4%B8%80%E4%B8%AA%E8%A7%92%E5%BA%A6%E8%B0%88%E6%AF%8D%E5%A9%B4%E7%94%B5%E5%95%86%E7%9A%84%E7%BA%BF%E4%B8%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>Q: 如果有1万家母婴店，和2万家线下门店（超市，母婴等），哪家价值更大呢？<br>A: 显然是1万家母婴店。</p><p>Q: 如果有1万家母婴店，怎么实现盈利呢？</p><p><strong>收银软件</strong></p><p>线下的收银软件，大都功能单一，只做收银，且软件不免费，或者功能不免费。</p><p>新·收银应该具备哪些功能呢？</p><ol><li>基本收银功能</li><li>线下+线下互通: 零售 + 微商城</li><li>会员管理：个性化的服务</li><li>服务收银：洗澡，游泳等</li></ol><p>服务产品一般都只会在线上提供，但是获客成本越来越高，好多店铺开始转向线下，美其名曰：用互联网思维做实业。</p><p><strong>想从渠道的角度来谈一谈。</strong></p><p>线下的渠道有更多的好处<br>1、 更多：给一些潜在的互联网用户提供服务，平台也能获取新用户。<br>2、 更大：在线上流量如此难以获取的今天，三线以下城市，还有大量的流量没有获取。<br>3、 更丰富：金融、医疗、知识、早教、旅游、保险、人工智能等更丰富的产品将带给线下的客服。</p><p>线上的渠道<br>1、和供应商合作：以更低廉的价格获取产品<br>2、和制造商合作：将个性化需求反馈给制造商<br>3、和品牌商合作：广告、活动等<br>4、其他效应：和其他公司合作等</p><p>通过线下的渠道想要获利，还是很难的，店主，一个比一个精明，所以更好的方式：就是羊毛出在猪身上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>记一件小事 —— 非理性消费</title>
    <link href="/2017/12/03/%E8%AE%B0%E4%B8%80%E4%BB%B6%E5%B0%8F%E4%BA%8B-%E2%80%94%E2%80%94-%E9%9D%9E%E7%90%86%E6%80%A7%E6%B6%88%E8%B4%B9/"/>
    <url>/2017/12/03/%E8%AE%B0%E4%B8%80%E4%BB%B6%E5%B0%8F%E4%BA%8B-%E2%80%94%E2%80%94-%E9%9D%9E%E7%90%86%E6%80%A7%E6%B6%88%E8%B4%B9/</url>
    
    <content type="html"><![CDATA[<p>事情来源于一件小事：口碑送了一个20-5的商圈红包，今天过期。</p><p>想了想不用好亏，去买点泸溪河的面食吧，20-5块，真的好便宜。找下附近的门店，有家在商圈范围内，可以用。</p><p>到了门店，我擦，比隔壁那家店，排队的人多了3-4倍，算了，为了省钱忍了。过了会，擦，两个老人竟然插队，算了，不和她们计较了。又过了会，一个女的插件，跟店员无助的抱怨道：她插队。店员管都没管，算了，不计较了。</p><p>本来打算买绿豆饼 + 麻花, 但是看到蛋糕好好吃的样子，就瞬间改变主意了。</p><p>我：绿豆饼 + 麻花 + 蛋糕<br>店员：我们蛋糕做活动哦，买一送一。<br>我：那我不要麻花了，给我来一份。心想，反正买一送一，真便宜。顺便瞥了一眼价格， 18.3元。不够啊，再来4个肉松小贝。</p><p>最后的价格见下图。<br><img src="http://img.blog.csdn.net/20171203201001064" alt="价格"></p><p>误区：</p><ol><li>买一送一的蛋糕不是无水蛋糕</li><li>多买了：买三样，价格就够了，我算的是两样18.3元。</li></ol><p>生活中，遇到过，香葱口味饼干14.9元，其他口味饼干促销9.9。竟然这样说服自己，反正味道差不多，9.9元，省好多哦，就买其他口味的了。</p><p><strong>很少因为自己的喜欢而坚持，买的原因是因为便宜，仅仅是，同类物品，这个价格低点，或者买一送一。</strong></p><p>看了一样，刚才买一送一的。生产日期，12月2号，保质期3天。（今天是12月3号）<strong>自己认为的占便宜，很多时候，真的就占便宜了吗？</strong></p><p>这是一件小事，也许从另外一个角度，这并不是一件小事。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>联通不止一面</title>
    <link href="/2017/11/26/%E8%81%94%E9%80%9A%E4%B8%8D%E6%AD%A2%E4%B8%80%E9%9D%A2/"/>
    <url>/2017/11/26/%E8%81%94%E9%80%9A%E4%B8%8D%E6%AD%A2%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20171126125555241" alt="中国联通"></p><p>想在联通办个业务，发现客户端有，没办成功，于是，找了客服，客服回复要去营业厅去办。</p><p>然后，在客户端办理成功了。</p><p>打了个电话，给客户反馈一下，你们这个功能，可以再客户端办理，不用到线下那么麻烦。然后，客服说，这个业务，要去线下办理，客户端办理可能会有问题。我说反馈给经理，客服说不保证经理会给回复，然后还要主动联系经理，给了个总经理电话，周末还不上班。</p><p>联通的客户端功能有问题，还让用户用，后果还客户承担。功能有问题，就不应该上这个功能啊！！和腾讯这些公司的体验差了十五八千里，反正他们也不愁盈利。</p><ol><li><p>联通不止一面，对于其他事物呢？<br>好的东西，都不止一面，在你看来是好的，在别人看来可能就是坏的，我们要辩证的看待。</p></li><li><p>爱用不用，不用滚<br>这个世界本来就是弱肉强食，有些落后的东西注定会被淘汰。</p></li></ol><p>最后，淡定，你懂就可以，其他人的利益，也管不了那么多了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>辩证 我的故事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>熬好了鸡汤，忘记给汤勺</title>
    <link href="/2017/11/20/%E7%86%AC%E5%A5%BD%E4%BA%86%E9%B8%A1%E6%B1%A4%EF%BC%8C%E5%BF%98%E8%AE%B0%E7%BB%99%E6%B1%A4%E5%8B%BA/"/>
    <url>/2017/11/20/%E7%86%AC%E5%A5%BD%E4%BA%86%E9%B8%A1%E6%B1%A4%EF%BC%8C%E5%BF%98%E8%AE%B0%E7%BB%99%E6%B1%A4%E5%8B%BA/</url>
    
    <content type="html"><![CDATA[<p>今天刚好有空，去了下新华书店。</p><p>看到了新上了好多书。得到app上的一个作者成甲的《好好学习：个人知识管理精进指南》，和著名读书人古典老师最新出的书《跃迁 成为高手的技术》。</p><p>读了一点，就不想看下去了，看出来是比较用心，但是总觉得缺少了什么，怎么比喻呢，熬好了大补的鸡汤，却忘记给汤勺。</p><p>刚才去京东上看了下销售很好，感觉整个社会对于成功的急切。想了下，他们的分类是在励志与成功，突然觉得有道理的。</p><p>晚上看了最新的一期《极限挑战》——第三季最后一集，在那里面，我找到了一点提示。</p><p>人生是没有捷径的，所谓的通过一本书，就想成为多牛逼的人，简直是在妄想。它们最多给了一点点启示，可是国内的成功励志书呢？大都是心灵鸡汤，没有给“汤勺”。</p><p>现在，越来越喜欢国外的书籍。<br>耐下心，或许，我们可以找到答案。</p>]]></content>
    
    
    
    <tags>
      
      <tag>我的故事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>又在雨天丢了一把伞</title>
    <link href="/2017/11/19/%E5%8F%88%E5%9C%A8%E9%9B%A8%E5%A4%A9%E4%B8%A2%E4%BA%86%E4%B8%80%E6%8A%8A%E4%BC%9E/"/>
    <url>/2017/11/19/%E5%8F%88%E5%9C%A8%E9%9B%A8%E5%A4%A9%E4%B8%A2%E4%BA%86%E4%B8%80%E6%8A%8A%E4%BC%9E/</url>
    
    <content type="html"><![CDATA[<p>周五，急急忙忙赶车，又丢了一把伞，虽然不是什么贵重的东西，但是那一阵，心情不是不好，最后，还淋了一点雨。</p><p>我们或多或少，在急急忙忙中会忘记去做一些事情。</p><p>上了某乎，搜了下了给的答案</p><ol><li>预留足够的时间（避免太急，打乱节奏）</li><li>检查要带的东西（做List）</li><li>少带东西</li><li>在合适的东西上留下姓名和联系方式 </li><li>自嘲：因为穷</li><li>极端：不出门</li></ol><p>总的来说，那一刻注意力在别处。不要急，多放点注意力，在关心的东西上。</p><p>如果丢了，不是太贵重的东西，别放太多精力在沉默成本上，向前看。贵重的东西愣着干嘛，快去找啊。</p><hr><p>想到另外一个问题：<br>怎么降低找东西的成本？<br>整理术？我也不清楚，抽空想下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>我的故事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在重复的每一天中，偷一会懒</title>
    <link href="/2017/11/16/%E5%9C%A8%E9%87%8D%E5%A4%8D%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%E4%B8%AD%EF%BC%8C%E5%81%B7%E4%B8%80%E4%BC%9A%E6%87%92/"/>
    <url>/2017/11/16/%E5%9C%A8%E9%87%8D%E5%A4%8D%E7%9A%84%E6%AF%8F%E4%B8%80%E5%A4%A9%E4%B8%AD%EF%BC%8C%E5%81%B7%E4%B8%80%E4%BC%9A%E6%87%92/</url>
    
    <content type="html"><![CDATA[<p>每天都是一样的重复，让人感觉不到区别。</p><p>今天早上一不小心睡过了，跟主管请了个假，也同意了。所以就看到了和正常上班时间，不一样的一面。图书馆，路上也没啥人，连肯德基的早餐也不卖了。不过，通往总统府的路上倒是络绎不绝。</p><p>就在这么一丝丝空隙中，感受到了一些生活的气息。</p><p>生活的气息是什么？<br>我觉得第一个区别就是节奏慢，没有那么快的节奏，你可以看到世界不一样的一面。有的人在准备早餐，有的人在清洁马路，有的人去图书馆学习。</p><p>早上到了办公室，就看到了小伙伴，黑压压的一片，我们的团队真的壮大了。工作上，最舍不得的就是我们的小伙伴，朝夕相处。</p><p>发生了这个小插曲，接下来要做的事情</p><ol><li>调整闹铃时间，别拖延。</li><li>如果要找不到事情，就写点代码吧，而不是去看代码。</li><li>有机会，从不一样的角度看待世界。长期的重复导致那些稀疏平常，显得弥足珍贵</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>我的故事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>职业病</title>
    <link href="/2017/11/05/%E8%81%8C%E4%B8%9A%E7%97%85/"/>
    <url>/2017/11/05/%E8%81%8C%E4%B8%9A%E7%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我的职业病就是“折腾”</p><p>当事情已经有了解决方案A,会去考虑是否有更好的解决方案B,或者会去考虑是否有其他方案C？</p><p>折腾就是在寻找其他的可能性，“折腾”有好有坏，但是常常在事前，我们是并不知道的。但是“折腾”多了，你也就知道方案的好坏。</p><p>有的人是不愿意折腾的，因为折腾意味着不稳定，和我们常说的“安全感”背道而驰。但是有的时候因为更“好”在诱惑，所以很多人也愿意尝试。</p><p>所以该如何决定？</p><h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>升级的过程中，是有风险的，风险或大或小。</p><p>我们觉得好的东西，有时候喜欢强加给别人，小白觉得的确很好啊，但是如果无法回退到之前的状态，TA就会来怪罪于你。</p><h2 id="递进关系"><a href="#递进关系" class="headerlink" title="递进关系"></a>递进关系</h2><p>比如你提供A方案<br>如果有更优的B方案，但是有风险，选择B方案，会造成A方案失效，那还是别去做。<br>如果有更优的B方案，且可以回退到之前的方案这种情况下才可能去做。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><table><thead><tr><th>类型</th><th style="text-align:right">不可回退到之前状态</th><th style="text-align:right">可以回退到之前状态（成本有高低）</th></tr></thead><tbody><tr><td>小白</td><td style="text-align:right">别做</td><td style="text-align:right">衡量去做</td></tr><tr><td>入门</td><td style="text-align:right">告知风险，尽量别做</td><td style="text-align:right">衡量去做</td></tr><tr><td>高端</td><td style="text-align:right">告知风险，让其决定</td><td style="text-align:right">衡量去做</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自己的生活已经如此的累，没有必要为别人提供更好的解决方案，及时有，那也是付费的。</p><hr><p>2017-11-09 更新：</p><ol><li>有时候，我们认为的更好只是主观行为，并不一定是更好的，是由我们的价值观决定的。</li><li>没有解决问题的“折腾”，都是瞎折腾</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>我的故事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“穷人”的思维</title>
    <link href="/2017/11/03/%E2%80%9C%E7%A9%B7%E4%BA%BA%E2%80%9D%E7%9A%84%E6%80%9D%E7%BB%B4/"/>
    <url>/2017/11/03/%E2%80%9C%E7%A9%B7%E4%BA%BA%E2%80%9D%E7%9A%84%E6%80%9D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="情景："><a href="#情景：" class="headerlink" title="情景："></a>情景：</h2><p>最近在苏宁买相机，下了三笔订单<br>第一单 4096元 线下<br>第二单 3997元 线上<br>第三单 3999元 线上</p><p>第二单是因为第一单嫌贵，然后下的。<br>第三单是因为12月免息 + 单肩包</p><p>最后的结果是下了第三单后，取消第二单。第三单虽然下单，但是支付不了，最后什么都没得到。</p><p>穷人的想法是想占尽所有的好处，却不知道有些事情看似无风险，其实是高风险。</p><table><thead><tr><th>分类</th><th style="text-align:right">以为的风险</th><th style="text-align:center">收益</th><th style="text-align:center">实际风险</th><th style="text-align:center">实际收益</th></tr></thead><tbody><tr><td>第一单</td><td style="text-align:right">无</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td>第二单</td><td style="text-align:right">无</td><td style="text-align:center">100元</td><td style="text-align:center">无</td><td style="text-align:center">100元</td></tr><tr><td>第三单</td><td style="text-align:right">无</td><td style="text-align:center">12月免息 + 单肩包</td><td style="text-align:center">订单无法支付</td><td style="text-align:center">无（归0）</td></tr></tbody></table><h2 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h2><p>以为：下单一定能够支付<br>实际：下单不一定能够支付成功<br>实际操作：第三单下单（未支付），取消第二单。<br>建议：同时支付两单，最后并退款。<br>联想：找工作的时候的骑驴找马</p><h2 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h2><p>以为的：<br>本金：相机购买权<br>利益：12月免息 + 单肩包<br>风险：0%</p><p>实际的：<br>本金：损失<br>利益：0<br>风险：100%<br>额外损失：补救的解决方案的成本(时间，金钱)，最后还没解决问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>决策时往往只看到利益，而不注意风险。</li><li>信息不对称时，决策的风险是很大的。</li><li>客服的作用就是转移你的注意力，并不是帮你解决问题。（潜台词：很抱歉，但是我帮不上忙）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>我的故事 穷人 思维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间与效率</title>
    <link href="/2017/11/01/%E6%97%B6%E9%97%B4%E4%B8%8E%E6%95%88%E7%8E%87/"/>
    <url>/2017/11/01/%E6%97%B6%E9%97%B4%E4%B8%8E%E6%95%88%E7%8E%87/</url>
    
    <content type="html"><![CDATA[<p>今天把办公的4G内存升级到了8G，大大提高了效率。  </p><p>平时开个PhpStorm、chrome，电脑就卡到爆，换完之后流程了好多，效率提升了不少。</p><p>平时，电脑一卡，老是被打断，这个时候会看看别处，导致不容易专心。对于程序员，切换进程的成本有点高。</p><p>提升效率的工具<br>1、IDE （如phpstorm）<br>2、思维导图 （用的processOn，百度脑图也可以）<br>3、<a href="https://shimo.im/">石墨文档</a><br>4、FE助手<br>5、Google<br>6、双显示屏</p>]]></content>
    
    
    
    <tags>
      
      <tag>我的故事 时间 效率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不忘本心，做自己</title>
    <link href="/2017/10/15/%E4%B8%8D%E5%BF%98%E6%9C%AC%E5%BF%83%EF%BC%8C%E5%81%9A%E8%87%AA%E5%B7%B1/"/>
    <url>/2017/10/15/%E4%B8%8D%E5%BF%98%E6%9C%AC%E5%BF%83%EF%BC%8C%E5%81%9A%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>最近和女朋友争执了一个问题。</p><p>女朋友刚换了一家新公司，作为一个”老”人，在发现新公司的流程上有一些问题。然后就汇报给主管，主管就说这个事不做，被怼回去了。她就不爽了，因为主管不听，就按照主管说的去做了，然后说再也不提意见了。</p><p>我说：你改提，照样提的啊，对的事情就应该去做。然后就吵了起来。当然，自认为对的问题，还是要考虑下的。</p><h2 id="价值观很重要"><a href="#价值观很重要" class="headerlink" title="价值观很重要"></a>价值观很重要</h2><p>毕业后，来到一家上市公司，扁平化的管理。给我的价值观就是，我只要做对的事情，会有人支持我的。主管不行，可以找经理、总监。</p><p>刚开始因为年少无知，闹了点笑话。但是就是这样，我才一点点成长。也感觉公司的人，给我带来正确的价值观。</p><p>下面是引自《熔炉》的话，希望我们能依旧不忘本心，勇敢做自己。</p><blockquote><p>我们之所以战斗不是为了改变世界，而是为了不让世界改变我们。冬天之所以那么冷是为了告诉大家身边人的温暖有多重要。世界上最美丽最珍贵的，反而是听不见且看不清的，只能用心才能感受得到。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>娱乐至死，我们终将毁于我们热爱的东西</title>
    <link href="/2017/10/14/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E7%BB%88%E5%B0%86%E6%AF%81%E4%BA%8E%E6%88%91%E4%BB%AC%E7%83%AD%E7%88%B1%E7%9A%84%E4%B8%9C%E8%A5%BF/"/>
    <url>/2017/10/14/%E5%A8%B1%E4%B9%90%E8%87%B3%E6%AD%BB%EF%BC%8C%E6%88%91%E4%BB%AC%E7%BB%88%E5%B0%86%E6%AF%81%E4%BA%8E%E6%88%91%E4%BB%AC%E7%83%AD%E7%88%B1%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>娱乐业时代</p><ol><li>娱乐方面：比如游戏、直播、明星等娱乐行业，镜头前的人赚的喷薄</li><li>广告方面：商品的质量和用途在展示商品技巧面前无足轻重</li><li>专业的演员 和 较真的人 让人有点乏味</li></ol><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li><p>媒介即信息<br>语言/日常生活的交流:有背景<br>电报：无背景，使脱离语境的信息合法化，传播信息<br>文字/纸张：抽象化，收集信息<br>电视：具象化<br>摄影：具体的，但无法提供观点<br>互联网：信息传播速度更快</p></li><li><p>媒介是会话<br>会话：交流信息的技巧和技术</p></li></ol><h2 id="媒介即认识论"><a href="#媒介即认识论" class="headerlink" title="媒介即认识论"></a>媒介即认识论</h2><ol><li>通过共鸣，某些特定语境中的某个特定说法获得了普遍的意义<br>梁祝代表爱情<br>爱丽丝漫游<br>漫威电影<br>都有了所谓的意义</li><li>共鸣，就是扩大的隐喻，它超越了这个语境并延伸到未知。</li><li>一种重要的新媒介会改变话语的结构，旧的媒介（象形文字等）也正在消失</li></ol><h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><ol><li>时间的碎片化，一个支离破碎的世界</li><li>我们不再怀疑媒介带给的信息</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>当我们想的时候，想想为什么会笑？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>感知哈希算法（pHash算法）</title>
    <link href="/2017/10/10/%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%88pHash%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <url>/2017/10/10/%E6%84%9F%E7%9F%A5%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%EF%BC%88pHash%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>第一步，缩小尺寸。<br>将图片缩小到8x8的尺寸，总共64个像素。这一步的作用是去除图片的细节，只保留结构、明暗等基本信息，摒弃不同尺寸、比例带来的图片差异。</p><p> 第二步，简化色彩。<br> 将缩小后的图片，转为64级灰度。也就是说，所有像素点总共只有64种颜色。</p><p> 第三步，计算平均值。<br> 计算所有64个像素的灰度平均值。</p><p> 第四步，比较像素的灰度。<br> 将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。</p><p> 第五步，计算哈希值。<br> 将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。</p><h1 id="汉明距离"><a href="#汉明距离" class="headerlink" title=" 汉明距离"></a> 汉明距离</h1><p> 定义：在信息论中，两个等长字符串之间的汉明距离（英语：Hamming distance）是两个字符串对应位置的不同字符的个数。换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数。</p><h2 id="例子："><a href="#例子：" class="headerlink" title=" 例子："></a> 例子：</h2><ul><li>1011101与1001001之间的汉明距离是2。</li><li>2143896与2233796之间的汉明距离是3。</li><li><p>“toned”与”roses”之间的汉明距离是3。</p><h1 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h1></li></ul><ol><li><p><a href="https://github.com/jenssegers/imagehash">https://github.com/jenssegers/imagehash</a></p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1></li><li><a href="http://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html">http://www.hackerfactor.com/blog/?/archives/529-Kind-of-Like-That.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html">http://www.ruanyifeng.com/blog/2011/07/principle_of_similar_image_search.html</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>php获取js执行的页面</title>
    <link href="/2017/10/09/php%E8%8E%B7%E5%8F%96js%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <url>/2017/10/09/php%E8%8E%B7%E5%8F%96js%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>安装phantomjs</strong><br>yum install phantomjs</p><p><strong>安装相关包</strong><br>composer require “jonnyw/php-phantomjs:4.*”</p><p><strong>Demo:</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&#x27;vendor/autoload.php&#x27;</span>;<br><span class="hljs-keyword">use</span> <span class="hljs-title">JonnyW</span>\<span class="hljs-title">PhantomJs</span>\<span class="hljs-title">Client</span>;<br><br><span class="hljs-variable">$client</span> = Client::getInstance();<br><br><span class="hljs-variable">$client</span>-&gt;getEngine()-&gt;setPath(<span class="hljs-string">&#x27;/usr/bin/phantomjs&#x27;</span>); <span class="hljs-comment">//设置phantomjs位置</span><br><span class="hljs-variable">$client</span>-&gt;getEngine()-&gt;addOption(<span class="hljs-string">&#x27;--load-images=false&#x27;</span>);<br><span class="hljs-variable">$client</span>-&gt;getEngine()-&gt;addOption(<span class="hljs-string">&#x27;--ignore-ssl-errors=true&#x27;</span>);<br><br><span class="hljs-variable">$url</span> = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>;<br><span class="hljs-variable">$request</span> = <span class="hljs-variable">$client</span>-&gt;getMessageFactory()-&gt;createRequest(<span class="hljs-variable">$url</span>, <span class="hljs-string">&#x27;GET&#x27;</span>);<br><br><span class="hljs-variable">$timeout</span> = <span class="hljs-number">10000</span>; <span class="hljs-comment">//设置超时</span><br><span class="hljs-variable">$request</span>-&gt;setTimeout(<span class="hljs-variable">$timeout</span>);<br><br><span class="hljs-variable">$request</span>-&gt;addSetting(<span class="hljs-string">&#x27;userAgent&#x27;</span>, <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36&#x27;</span>);<span class="hljs-comment">//设置ua</span><br><br><span class="hljs-variable">$response</span> = <span class="hljs-variable">$client</span>-&gt;getMessageFactory()-&gt;createResponse();<br><span class="hljs-variable">$client</span>-&gt;send(<span class="hljs-variable">$request</span>, <span class="hljs-variable">$response</span>);<br><br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$response</span>-&gt;getContent();<br></code></pre></td></tr></table></figure></p><p><strong>参考资料：</strong></p><ol><li><a href="http://jonnnnyw.github.io/php-phantomjs/">php-phantomjs</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>phantomjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>麦肯锡工作法 （第一读）</title>
    <link href="/2017/09/18/%E9%BA%A6%E8%82%AF%E9%94%A1%E5%B7%A5%E4%BD%9C%E6%B3%95-%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BB%EF%BC%89/"/>
    <url>/2017/09/18/%E9%BA%A6%E8%82%AF%E9%94%A1%E5%B7%A5%E4%BD%9C%E6%B3%95-%EF%BC%88%E7%AC%AC%E4%B8%80%E8%AF%BB%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是专业？"><a href="#什么是专业？" class="headerlink" title="什么是专业？"></a>什么是专业？</h1><ol><li>客户第一</li><li>积极应对（太多）</li><li>工作应该尽善尽美</li><li>一点灵感</li><li>重视外表</li><li>行家</li><li>不要只解决眼前的问题<br>需要解决根本问题,不然下次还可能继续发生</li></ol><h1 id="解决问题的方法论"><a href="#解决问题的方法论" class="headerlink" title="解决问题的方法论"></a>解决问题的方法论</h1><p>一、分析框架<br>    就是别人造的，验证好的壳</p><pre><code>1. 位置矩阵2. 议论文三段论3. 3C框架4. 7S框架5. SWOT6. STAR 面试法</code></pre><p>二、处理信息</p><p>三、提高解决问题的能力</p><p>四、提高自身能力</p><ol><li>发挥自己的价值</li><li>携带简单的工具</li><li>拥有目标</li><li>不做评判<br>不对事情的正确性做评判，主要看得到什么</li><li>请前辈吃饭，和前辈交流</li></ol><p>五、创造性的能力</p><p>六、演示的技巧                                                                                                                                                                                                                                                                                      </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Node入门</title>
    <link href="/2017/09/15/Node%E5%85%A5%E9%97%A8/"/>
    <url>/2017/09/15/Node%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>一、web示例<br>server.js<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">var http = require(<span class="hljs-string">&quot;http&quot;</span>);<br><br>http.createServer(<span class="hljs-keyword">function</span>(<span class="hljs-built_in">request</span>, <span class="hljs-built_in">response</span>) &#123;<br>  <span class="hljs-built_in">response</span>.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span>&#125;);<br>  <span class="hljs-built_in">response</span>.write(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>  <span class="hljs-built_in">response</span>.<span class="hljs-keyword">end</span>();<br>&#125;).listen(<span class="hljs-number">8888</span>);<br></code></pre></td></tr></table></figure></p><p>二、进行函数传递<br>say是作为函数传递，而不是值。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span>(word) &#123;<br>  console.log(word);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title">execute</span>(someFunction, value) &#123;<br>  someFunction(value);<br>&#125;<br><br>execute(say, <span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure></p><p>三、基于事件驱动的回调<br>相关阅读：！<a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb">Understanding node.js</a></p><p>四、服务端的模块<br>server.js不算一个模块，我们进行封装<br><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var http = require(&quot;http&quot;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-keyword">start</span>() &#123;<br>  <span class="hljs-keyword">function</span> onRequest(request, response) &#123;<br>    console.log(&quot;Request received.&quot;);<br>    response.writeHead(<span class="hljs-number">200</span>, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;);<br>    response.<span class="hljs-keyword">write</span>(&quot;Hello World&quot;);<br>    response.<span class="hljs-keyword">end</span>();<br>  &#125;<br><br>  http.createServer(onRequest).<span class="hljs-keyword">listen</span>(<span class="hljs-number">8888</span>);<br>  console.log(&quot;Server has started.&quot;);<br>&#125;<br><br>exports.start = <span class="hljs-keyword">start</span>;<br></code></pre></td></tr></table></figure></p><p>五、路由问题<br>需要的模块：url和querystring模块<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                               url.parse(string).query<br>                                           |<span class="hljs-string"></span><br><span class="hljs-string">           url.parse(string).pathname      </span>|<br>                       |<span class="hljs-string">                   </span>|<br>                       |<span class="hljs-string">                   </span>|<br>                     ------ -------------------<br>http://localhost:8888/start?foo=bar&amp;hello=world<br>                                ---       -----<br>                                 |<span class="hljs-string">          </span>|<br>                                 |<span class="hljs-string">          </span>|<br>              querystring(string)[<span class="hljs-string">&quot;foo&quot;</span>]    |<span class="hljs-string"></span><br><span class="hljs-string">                                            </span>|<br>                         querystring(string)[<span class="hljs-string">&quot;hello&quot;</span>]<br></code></pre></td></tr></table></figure></p><p>相关代码<br><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;http&quot;</span>);<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">url</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;url&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onRequest</span>(<span class="hljs-params">request, response</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> pathname = <span class="hljs-built_in">url</span>.parse(request.url).pathname;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Request for &quot;</span> + pathname + <span class="hljs-string">&quot; received.&quot;</span>);<br>    response.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;text/plain&quot;</span>&#125;);<br>    response.write(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    response.end();<br>  &#125;<br><br>  http.createServer(onRequest).listen(<span class="hljs-number">8888</span>);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Server has started.&quot;</span>);<br>&#125;<br><br>exports.start = start;<br></code></pre></td></tr></table></figure></p><p>六、行为驱动执行</p><p>场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的经济分析模型</title>
    <link href="/2017/07/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2017/07/05/%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="经济动力"><a href="#经济动力" class="headerlink" title="经济动力"></a>经济动力</h2><p>1、生产率的提高<br>    生产率含义：生产率是有效运用创意和资源，提高产品和服务的附加价值，是某段时间内每一单位劳动投入所得的产量，以较少的资源投入生产出较多的产品即是生产率提高。<br>2、短期债务周期<br>3、长期债务周期</p><h2 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h2><p>1、交换<br>    买方：信用、货币<br>    卖方：商品、服务、金融资产</p><p>2、公式<br>    支出总额 = 信用 + 货币<br>    价格 = 支出总额 / 销量</p><h2 id="信贷"><a href="#信贷" class="headerlink" title="信贷"></a>信贷</h2><p>1、向未来的自己借钱，形成周期。</p><p>2、资产 + 负债</p><p>3、增加支出<br>    无信贷：提高生产率<br>    有信贷：提高生产率 + 借债</p><p>4、短期分析<br>    信贷会导致支出增加，引起价格上涨，形成通货膨胀。<br>    -&gt; 央行：提高利率来减少信贷<br>    -&gt; 导致支出减少，从而价格下跌，形成通货紧缩。<br>    -&gt; 央行：减少利率没用，需要<br>    短期债务周期：信贷是否易于获得</p><p>5、长期：减少利率没用，需要去杠杆化</p><ul><li>消减支出</li><li>减少债务</li><li>财富再分配</li><li>发型货币 （央行 购买金融资产，ZF 购买服务 + 商品）</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、不要让债务的增产速度超过收入<br>2、不要让收入的增长速度超过生产率<br>3、尽一切努力提高生产率</p>]]></content>
    
    
    
    <tags>
      
      <tag>经济</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为NexT主题添加文章阅读量统计功能</title>
    <link href="/2017/07/03/%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/"/>
    <url>/2017/07/03/%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>网上找了一大堆博客，发现添加方式很繁琐。统计的方式有LeanCloud和不蒜子。本文介绍的是不蒜子统计方法。</p><h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><p>打开文件：<br>themes/next/_config.yml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Show PV/UV of the website/page with busuanzi.</span><br><span class="hljs-comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="hljs-attr">busuanzi_count:</span><br>  <span class="hljs-comment"># count values only if the other configs are false</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-comment"># custom uv span for the whole site</span><br>  <span class="hljs-attr">site_uv:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">site_uv_header:</span> <span class="hljs-string">&lt;i</span> <span class="hljs-string">class=&quot;fa</span> <span class="hljs-string">fa-user&quot;&gt;&lt;/i&gt;</span> <span class="hljs-string">访问人数</span><br>  <span class="hljs-attr">site_uv_footer:</span> <span class="hljs-string">人</span><br>  <span class="hljs-comment"># custom pv span for the whole site</span><br>  <span class="hljs-attr">site_pv:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">site_pv_header:</span> <span class="hljs-string">&lt;i</span> <span class="hljs-string">class=&quot;fa</span> <span class="hljs-string">fa-eye&quot;&gt;&lt;/i&gt;</span> <span class="hljs-string">总访问量</span><br>  <span class="hljs-attr">site_pv_footer:</span> <span class="hljs-string">次</span><br>  <span class="hljs-comment"># custom pv span for one page only</span><br>  <span class="hljs-attr">page_pv:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">page_pv_header:</span> <span class="hljs-string">&lt;i</span> <span class="hljs-string">class=&quot;fa</span> <span class="hljs-string">fa-file-o&quot;&gt;&lt;/i&gt;</span> <span class="hljs-string">阅读数</span><br>  <span class="hljs-attr">page_pv_footer:</span><br></code></pre></td></tr></table></figure></p><p>相关操作：</p><ol><li>enable: true</li><li>添加相关中文说明，不添加也行。</li></ol><h2 id="效果展示："><a href="#效果展示：" class="headerlink" title="效果展示："></a>效果展示：</h2><p><a href="https://han8gui.github.io">博客链接</a></p><p>阅读数<br><img src="http://img.blog.csdn.net/20170703160120649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGltZTg4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>访客数，以及访问量<br><img src="http://img.blog.csdn.net/20170703160149134?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGltZTg4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>更多文章：<br>1.<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html">为NexT主题添加文章阅读量统计功能</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>不蒜子 博客统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转]理解Javascript中的事件绑定与事件委托</title>
    <link href="/2017/07/03/%E8%BD%AC-%E7%90%86%E8%A7%A3Javascript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <url>/2017/07/03/%E8%BD%AC-%E7%90%86%E8%A7%A3Javascript%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E4%B8%8E%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    
    <content type="html"><![CDATA[<h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><h2 id="最直接的事件绑定：HTML事件处理程序"><a href="#最直接的事件绑定：HTML事件处理程序" class="headerlink" title="最直接的事件绑定：HTML事件处理程序"></a>最直接的事件绑定：HTML事件处理程序</h2><p>如下示例代码，通过节点属性显式声明，直接在HTML中，显式地为按钮绑定了click事件，当该按钮有用户点击行为时，便会触发myClickFunc方法。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* html */</span><br>&lt;button id=<span class="hljs-string">&quot;btn&quot;</span> onclick=<span class="hljs-string">&quot;myClickFunc()&quot;</span>&gt;<br>    ClickMe<br>&lt;/button&gt;<br><br><span class="hljs-regexp">/* js */</span><br><span class="hljs-regexp">//</span> 事件处理程序<br>var myClickFunc = <span class="hljs-keyword">function</span>(evt)&#123;<br>    <span class="hljs-regexp">//</span> TODO..<br>&#125;;<br><br><span class="hljs-regexp">//</span> 移除事件处理程序<br>myClickFunc = <span class="hljs-keyword">function</span>()&#123;&#125;;<br></code></pre></td></tr></table></figure><br>显而易见，这种绑定方式非常不友好，HTML代码和JS代码严重耦合在一起，比如当要修改一个函数名时候，就要修改两次，</p><h2 id="DOM-0-级事件处理程序"><a href="#DOM-0-级事件处理程序" class="headerlink" title="DOM 0 级事件处理程序"></a>DOM 0 级事件处理程序</h2><p>通过DOM操作动态绑定事件，是一种比较传统的方式，把一个函数赋值给事件处理程序。这种方式也是应用较多的方式，比较简单。看下面例子：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* html */</span><br>&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;ClickMe&lt;/button&gt;<br><br><span class="hljs-regexp">/* js */</span><br><span class="hljs-regexp">//</span> 事件处理程序<br>var myClickFunc = <span class="hljs-keyword">function</span>(evt)&#123;<br>    <span class="hljs-regexp">//</span> TODO ...<br>&#125;;<br><br><span class="hljs-regexp">//</span> 直接给DOM节点的 onclick 方法赋值，注意这里接收的是一个<span class="hljs-keyword">function</span><br>document.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = myClickFunc;<br><br><span class="hljs-regexp">//</span> 移除事件处理程序<br>document.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = null;<br></code></pre></td></tr></table></figure></p><h2 id="DOM-2-级事件处理程序"><a href="#DOM-2-级事件处理程序" class="headerlink" title="DOM 2 级事件处理程序"></a>DOM 2 级事件处理程序</h2><p>通过事件监听的方式绑定事件，DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作。<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// event: 事件名称</span><br><span class="hljs-comment">// function: 事件函数</span><br><span class="hljs-comment">// boolean: false | true, true 为事件捕获, false 为事件冒泡(默认);</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Ele</span>.</span></span>add<span class="hljs-constructor">EventListener(<span class="hljs-params">event</span>,<span class="hljs-params">function</span>[,<span class="hljs-params">boolean</span>])</span>; <span class="hljs-comment">// 添加句柄</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ELe</span>.</span></span>remove<span class="hljs-constructor">EventListener(<span class="hljs-params">event</span>,<span class="hljs-params">function</span>[,<span class="hljs-params">boolean</span>])</span>; <span class="hljs-comment">// 移除句柄</span><br>看个例子：<br><br><span class="hljs-comment">/* html */</span><br>&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;ClickMe&lt;/button&gt;<br><br><span class="hljs-comment">/* js */</span><br><span class="hljs-comment">// 通过DOM操作进行动态绑定：</span><br><span class="hljs-comment">// 获取btnHello节点</span><br>var oBtn = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">btn</span>&#x27;)</span>;<br> <br><span class="hljs-comment">// 增加第一个 click 事件监听处理程序</span><br>oBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">evt</span>)</span>&#123;<br>    <span class="hljs-comment">// TODO sth 1...</span><br>&#125;);<br> <br><span class="hljs-comment">// 增加第二个 click 事件监听处理程序</span><br>oBtn.add<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">evt</span>)</span>&#123;<br>    <span class="hljs-comment">// TODO sth 2...</span><br>&#125;);<br><br><span class="hljs-comment">// ps：通过这种形式，可以给btn按钮绑定任意多个click监听；注意，执行顺序与添加顺序相关。</span><br><br><span class="hljs-comment">// 移除事件处理程序</span><br>oBtn.remove<span class="hljs-constructor">EventListener(&#x27;<span class="hljs-params">click</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">evt</span>)</span>&#123;..&#125;);<br></code></pre></td></tr></table></figure></p><h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><p>DOM 2级事件处理程序在IE是行不通的，IE有自己的事件处理程序方法：attachEvent()和detachEvent()。这两个方法的用法与addEventListener()是一样的，但是只接收两个参数，一个是事件名称，另一个是事件处理程序的函数。为什么不使用第三个参数的原因呢？因为IE8以及更早的浏览器版本只支持事件冒泡。看个例子：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* html */</span><br>&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;ClickMe&lt;/button&gt;<br><br><span class="hljs-comment">/* js */</span><br>var oBtn = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">btn</span>&#x27;)</span>;<br><span class="hljs-comment">// 事件处理函数</span><br><span class="hljs-keyword">function</span> evt<span class="hljs-constructor">Fn()</span>&#123; <br>    console.log(this);<br>&#125;<br><span class="hljs-comment">// 添加句柄</span><br>oBtn.attach<span class="hljs-constructor">Event(&#x27;<span class="hljs-params">onclick</span>&#x27;,<span class="hljs-params">evtFn</span>)</span>;<br><br><span class="hljs-comment">// 移除句柄</span><br>oBtn.detach<span class="hljs-constructor">Event(&#x27;<span class="hljs-params">onclick</span>&#x27;,<span class="hljs-params">evtFn</span>)</span>;<br></code></pre></td></tr></table></figure><br>简易的跨浏览器解决方法<br>如果我们既要支持IE的事件处理方法，又要支持 DOM 2级事件，那么就要封装一个跨浏览器的事件处理函数，如果支持 DOM 2级事件，就用addEventListener，否则就用attachEvent。例子如下：<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//跨浏览器事件处理程序</span><br>var eventUtil = &#123;<br>    <span class="hljs-comment">// 添加句柄</span><br>    addHandler: <span class="hljs-keyword">function</span>(element, <span class="hljs-keyword">type</span>, handler)&#123;<br>        <span class="hljs-keyword">if</span>(element.addEventListener)&#123;<br>            element.add<span class="hljs-constructor">EventListener(<span class="hljs-params">type</span>, <span class="hljs-params">handler</span>, <span class="hljs-params">false</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(element.attachEvent)&#123;<br>            element.attach<span class="hljs-constructor">Event(&#x27;<span class="hljs-params">on</span>&#x27; + <span class="hljs-params">type</span>, <span class="hljs-params">handler</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            element<span class="hljs-literal">[&#x27;<span class="hljs-identifier">on</span>&#x27; + <span class="hljs-identifier">type</span>]</span> = handler;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 删除句柄</span><br>    removeHandler: <span class="hljs-keyword">function</span>(element, <span class="hljs-keyword">type</span>, handler)&#123;<br>        <span class="hljs-keyword">if</span>(element.removeEventListener)&#123;<br>            element.remove<span class="hljs-constructor">EventListener(<span class="hljs-params">type</span>, <span class="hljs-params">handler</span>, <span class="hljs-params">false</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(element.detachEvent)&#123;<br>            element.detach<span class="hljs-constructor">Event(&#x27;<span class="hljs-params">on</span>&#x27; + <span class="hljs-params">type</span>, <span class="hljs-params">handler</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            element<span class="hljs-literal">[&#x27;<span class="hljs-identifier">on</span>&#x27; + <span class="hljs-identifier">type</span>]</span> = null;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>var oBtn = document.get<span class="hljs-constructor">ElementById(&#x27;<span class="hljs-params">btn</span>&#x27;)</span>;<br><span class="hljs-keyword">function</span> evt<span class="hljs-constructor">Fn()</span>&#123;<br>    alert(&#x27;hello world&#x27;);<br>&#125;<br>eventUtil.add<span class="hljs-constructor">Handler(<span class="hljs-params">oBtn</span>, &#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">evtFn</span>)</span>;<br>eventUtil.remove<span class="hljs-constructor">Handler(<span class="hljs-params">oBtn</span>, &#x27;<span class="hljs-params">click</span>&#x27;, <span class="hljs-params">evtFn</span>)</span>;<br></code></pre></td></tr></table></figure></p><h1 id="事件冒泡和事件捕获"><a href="#事件冒泡和事件捕获" class="headerlink" title="事件冒泡和事件捕获"></a>事件冒泡和事件捕获</h1><p>在了解事件委托之前，要先了解下事件冒泡和事件捕获。</p><p>早期的web开发，浏览器厂商很难回答一个哲学上的问题：当你在页面上的一个区域点击时，你真正感兴趣的是哪个元素。这个问题带来了交互的定义。在一个元素的界限内点击，显得有点含糊。毕竟，在一个元素上的点击同时也发生在另一个元素的界限内。例如单击一个按钮。你实际上点击了按钮区域、body元素的区域以及html元素的区域。</p><p>伴随着这个问题，两种主流的浏览器Netscape和IE有不同的解决方案。Netscape定义了一种叫做事件捕获的处理方法，事件首先发生在DOM树的最高层对象(document)然后往最深层的元素传播。在图例中，事件捕获首先发生在document上，然后是html元素，body元素，最后是button元素。</p><p>IE的处理方法正好相反。他们定义了一种叫事件冒泡的方法。事件冒泡认为事件促发的最深层元素首先接收事件。然后是它的父元素，依次向上，知道document对象最终接收到事件。尽管相对于html元素来说，document没有独立的视觉表现，他仍然是html元素的父元素并且事件能冒泡到document元素。所以图例中噢噢那个button元素先接收事件，然后是body、html最后是document。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/112419-13b59e438dbb6c70.png" alt="图片"></p><h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>简单点说，事件冒泡就是事件触发时，会从目标DOM元素向上传播，直到文档根节点，一般情况下，会是如下形式传播：</p><p>targetDOM → parentNode → … → body → document → window</p><p>如果希望一次事件触发能在整个DOM树上都得到响应，那么就需要用到事件冒泡的机制。看下面示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* html */</span><br>&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;ClickMe&lt;/button&gt;<br><br><span class="hljs-comment">/* js */</span><br><span class="hljs-comment">// 给按钮增加click监听</span><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;button clicked&#x27;</span>);<br>&#125;,<span class="hljs-literal">false</span>);<br> <br><span class="hljs-comment">// 给body增加click监听</span><br><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;body clicked&#x27;</span>);<br>&#125;,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><br>在这种情况下，点击按钮“ClickMe”后，其自身的click事件会被触发，同时，该事件将会继续向上传播， 所有的祖先节点都将得到事件的触发命令，并立即触发自己的click事件；所以如上代码，将会连续弹出两个alert.</p><p>在有些时候，我们想让事件独立触发，所以我们必须阻止冒泡，用event的stopPropagation()方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;ClickMe&lt;/button&gt;<br><br><span class="hljs-comment">/* js */</span><br><span class="hljs-comment">// 给按钮增加click监听</span><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;button clicked&#x27;</span>);<br>    evt.stopPropagation(); <span class="hljs-comment">//阻止事件冒泡</span><br>&#125;,<span class="hljs-literal">false</span>);<br> <br><span class="hljs-comment">// 给body增加click监听</span><br><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>)</span>&#123;<br>    alert(<span class="hljs-string">&#x27;body clicked&#x27;</span>);<br>&#125;,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><br>此时，点击按钮后，只会触发按钮本身的click事件，得到一个alert效果；该按钮的点击事件，不会向上传播，body节点就接收不到此次事件命令。</p><p>需要注意的是：</p><p>不是所有的事件都能冒泡，如：blur、focus、load、unload都不能<br>不同的浏览器，阻止冒泡的方式也不一样，在w3c标准中，通过event.stopPropagation()完成， 在IE中则是通过自身的event.cancelBubble=true来完成。</p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托看起来挺难理解，但是举个生活的例子。比如，有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。举个例子</p><p>HTML结构：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul-item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><br>如果我们要点击li标签，弹出里面的内容，我们就需要为每个li标签绑定事件。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">function</span>()&#123;<br>    var oUlItem = document.getElementById(<span class="hljs-symbol">&#x27;ul-item</span>&#x27;)<span class="hljs-comment">;</span><br>    var oLi = oUlItem.getElementsByTagName(<span class="hljs-symbol">&#x27;li</span>&#x27;)<span class="hljs-comment">;</span><br>    for(<span class="hljs-name">var</span> i=0, l = oLi.length<span class="hljs-comment">; i &lt; l; i++)&#123;</span><br>        oLi[<span class="hljs-name">i</span>].addEventListener(<span class="hljs-symbol">&#x27;click</span>&#x27;,show)<span class="hljs-comment">;</span><br>    &#125;<span class="hljs-comment">;</span><br>    function show(<span class="hljs-name">e</span>)&#123;<br>        e = e || window.event<span class="hljs-comment">;</span><br>        alert(<span class="hljs-name">e.target.innerHTML</span>)<span class="hljs-comment">;</span><br>    &#125;<span class="hljs-comment">;</span><br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>虽然这样子能够实现我们想要的功能，但是如果这个UL中的LI子元素频繁的添加或删除，我们就需要在每次添加LI的时候为它绑定事件。这就添加了复杂度，并且造成内存开销较大。</p><p>更简单的方法是利用事件委托，当事件被掏到更上层的父节点的时候，通过检查事件的目标对象（target）来判断并获取事件源LI。<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name">function</span>()&#123;<br>    var oUlItem = document.getElementById(<span class="hljs-symbol">&#x27;ul-item</span>&#x27;)<span class="hljs-comment">;</span><br>    oUlItem.addEventListener(<span class="hljs-symbol">&#x27;click</span>&#x27;,show)<span class="hljs-comment">;</span><br>    function show(<span class="hljs-name">e</span>)&#123;<br>        e = e || window.event<span class="hljs-comment">;</span><br>        var src = e.target<span class="hljs-comment">;</span><br>        if(<span class="hljs-name">src</span> &amp;&amp; src.nodeName.toLowerCase() === <span class="hljs-symbol">&#x27;li</span>&#x27;)&#123;<br>            alert(<span class="hljs-name">src.innerHTML</span>)<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><br>这里我们为父节点UL添加了点击事件，当点击子节点LI标签的时候，点击事件会冒泡到父节点。父节点捕获到事件之后，通过判断e.target.nodeName来判断是否为我们需要处理的节点，并且通过e.target拿到了被点击的Li节点。从而可以获取到相应的信息，并做处理。</p><p>优点：</p><p>通过上面的介绍，大家应该能够体会到使用事件委托对于web应用程序带来的几个优点：</p><p>管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。<br>可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。<br>JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</p>]]></content>
    
    
    
    <tags>
      
      <tag>事件 JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS设置服务开机启动的方法</title>
    <link href="/2017/06/29/CentOS%E8%AE%BE%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2017/06/29/CentOS%E8%AE%BE%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="方法一：利用-chkconfig-来配置启动级别"><a href="#方法一：利用-chkconfig-来配置启动级别" class="headerlink" title="方法一：利用 chkconfig 来配置启动级别"></a>方法一：利用 chkconfig 来配置启动级别</h1><pre><code>在CentOS或者RedHat其他系统下，如果是后面安装的服务，如httpd、mysqld、postfix等，安装后系统默认不会自动启动的。就算手动执行 /etc/init.d/mysqld start 启动了服务，只要服务器重启后，系统仍然不会自动启动服务。 在这个时候，我们就需要在安装后做个设置，让系统自动启动这些服务，避免不必要的损失和麻烦。 其实命令很简单的，使用chkconfig即可。</code></pre><h2 id="chkconfig介绍"><a href="#chkconfig介绍" class="headerlink" title="chkconfig介绍"></a>chkconfig介绍</h2><p><strong>简介</strong><br>chkconfig命令检查、设置系统的各种服务。这是Red Hat公司遵循GPL规则所开发的程序，它可查询操作系统在每一个执行等级中会执行哪些系统服务，其中包括各类常驻服务。谨记chkconfig不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。</p><p><strong>语法</strong><br>–add：增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据； –del：删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据； –level&lt;等级代号&gt;：指定读系统服务要在哪一个执行等级中开启或关毕。</p><p>等级代号列表：<br>等级0表示：表示关机<br>等级1表示：单用户模式<br>等级2表示：无网络连接的多用户命令行模式 等级3表示：有网络连接的多用户命令行模式<br>等级4表示：不可用 等级5表示：带图形界面的多用户模式<br>等级6表示：重新启动</p><h2 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h2><p>systemctl命令是系统服务管理器指令，它实际上将 service 和 chkconfig 这两个命令组合到一起。有时候你执行chkconfig命令无效，需要执行systemctl命令。</p><p><strong>语法</strong></p><p><img src="http://img.blog.csdn.net/20170629093302415?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVGltZTg4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="语法"></p><h1 id="方法二：修改-etc-rc-d-rc-local-这个文件"><a href="#方法二：修改-etc-rc-d-rc-local-这个文件" class="headerlink" title="方法二：修改 /etc/rc.d/rc.local 这个文件"></a>方法二：修改 /etc/rc.d/rc.local 这个文件</h1><p>vi /etc/rc.d/rc.local<br>例如将 apache、mysql、samba、svn 等这些服务的开机自启动问题一起搞定：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#添加以下命令</span><br><span class="hljs-regexp">/usr/</span>sbin/apachectl start<br><span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/my</span>sqld start<br><span class="hljs-regexp">/etc/</span>rc.d<span class="hljs-regexp">/init.d/</span>smb start<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/subversion/</span>bin/svnserve -d<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用分析日志shell命令</title>
    <link href="/2017/06/26/%E5%B8%B8%E7%94%A8%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97shell%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/06/26/%E5%B8%B8%E7%94%A8%E5%88%86%E6%9E%90%E6%97%A5%E5%BF%97shell%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>1、查看有多少个IP访问：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">awk &#x27;&#123;print $<span class="hljs-number">1</span>&#125;&#x27; log_file|<span class="hljs-type">sort</span>|<span class="hljs-type">uniq</span>|<span class="hljs-type">wc</span> -l<br></code></pre></td></tr></table></figure><br>2、查看某一个页面被访问的次数：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;/index.php&quot;</span> log_file | wc -<span class="hljs-keyword">l</span><br><br><span class="hljs-number">3</span>、查看每一个IP访问了多少个页面：<br><br>awk <span class="hljs-string">&#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#x27;</span> log_file &gt; <span class="hljs-built_in">log</span>.txt<br><br><span class="hljs-keyword">sort</span> -n -t <span class="hljs-string">&#x27; &#x27;</span> -<span class="hljs-keyword">k</span> <span class="hljs-number">2</span> <span class="hljs-built_in">log</span>.txt 配合<span class="hljs-keyword">sort</span>进一步排序<br></code></pre></td></tr></table></figure><br>4、将每个IP访问的页面数进行从小到大排序：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">awk <span class="hljs-comment">&#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#x27; log_file | sort -n</span><br></code></pre></td></tr></table></figure><br>5、查看某一个IP访问了哪些页面：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">grep</span><span class="hljs-regexp"> ^111.111.111.111</span> log_file| awk <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$1</span>,<span class="hljs-variable">$7</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><br>6、去掉搜索引擎统计的页面：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">awk</span> <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$12</span>,<span class="hljs-variable">$1</span>&#125;&#x27;</span> log_file | grep<span class="hljs-regexp"> ^\&quot;Mozilla</span> | awk <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$2</span>&#125;&#x27;</span> |sort | uniq | wc -l<br></code></pre></td></tr></table></figure><br>7、查看2015年8月16日14时这一个小时内有多少IP访问:<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">awk</span> &#x27;&#123;print $<span class="hljs-number">4</span>,$<span class="hljs-number">1</span>&#125;&#x27; log_file | grep <span class="hljs-number">16</span>/Aug/<span class="hljs-number">2015</span>:<span class="hljs-number">14</span> | awk &#x27;&#123;print $<span class="hljs-number">2</span>&#125;&#x27;| sort | uniq | wc -l<br></code></pre></td></tr></table></figure><br>8、查看访问前十个ip地址<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; |<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr |head -10 access_log<br><br>uniq -c 相当于分组统计并把统计数放在最前面<br><span class="hljs-keyword">cat</span> access.<span class="hljs-keyword">log</span>|awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -10<br><br><span class="hljs-keyword">cat</span> access.<span class="hljs-keyword">log</span>|awk &#x27;&#123;counts[$(11)]+=1&#125;; END &#123;<span class="hljs-keyword">for</span>(url <span class="hljs-keyword">in</span> counts) <span class="hljs-keyword">print</span> counts[url], url&#125;<br></code></pre></td></tr></table></figure><br>9、访问次数最多的10个文件或页面<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coq">cat log_file|<span class="hljs-type">awk</span> &#x27;&#123;print $<span class="hljs-number">11</span>&#125;&#x27;|<span class="hljs-type">sort</span>|<span class="hljs-type">uniq</span> -c|<span class="hljs-type">sort</span> -nr | <span class="hljs-type">head</span> <span class="hljs-number">-10</span><br><br>cat log_file|<span class="hljs-type">awk</span> &#x27;&#123;print $<span class="hljs-number">11</span>&#125;&#x27;|<span class="hljs-type">sort</span>|<span class="hljs-type">uniq</span> -c|<span class="hljs-type">sort</span> -nr|<span class="hljs-type">head</span> <span class="hljs-number">-20</span><br><br>awk &#x27;&#123;print $<span class="hljs-number">1</span>&#125;&#x27; log_file |<span class="hljs-type">sort</span> -n -r |<span class="hljs-type">uniq</span> -c | <span class="hljs-type">sort</span> -n -r | <span class="hljs-type">head</span> <span class="hljs-number">-20</span> <br>访问量最大的前<span class="hljs-number">20</span>个ip<br></code></pre></td></tr></table></figure><br>10、通过子域名访问次数，依据referer来计算，稍有不准<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">cat</span> access.<span class="hljs-built_in">log</span> | awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span> | sed -e <span class="hljs-string">&#x27; s/http:\/\///&#x27;</span> -e <span class="hljs-string">&#x27; s/\/.*//&#x27;</span> | <span class="hljs-built_in">sort</span> | uniq -c | <span class="hljs-built_in">sort</span> -rn | head <span class="hljs-number">-20</span><br></code></pre></td></tr></table></figure><br>11、列出传输大小最大的几个文件<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> www.access.<span class="hljs-keyword">log</span> |awk &#x27;(<span class="hljs-variable">$7</span>~/\.php/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$10</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$1</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$4</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -nr|head -100<br></code></pre></td></tr></table></figure><br>12、列出输出大于200000byte(约200kb)的页面以及对应页面发生次数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> www.access.<span class="hljs-keyword">log</span> |awk &#x27;(<span class="hljs-variable">$10</span> &gt; 200000 &amp;&amp; <span class="hljs-variable">$7</span>~/\.php/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -<span class="hljs-keyword">n</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -100<br></code></pre></td></tr></table></figure><br>13、如果日志最后一列记录的是页面文件传输时间，则有列出到客户端最耗时的页面<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> www.access.<span class="hljs-keyword">log</span> |awk &#x27;(<span class="hljs-variable">$7</span>~/\.php/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$NF</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$1</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$4</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -nr|head -100<br></code></pre></td></tr></table></figure><br>14、列出最最耗时的页面(超过60秒的)的以及对应页面发生次数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> www.access.<span class="hljs-keyword">log</span> |awk &#x27;(<span class="hljs-variable">$NF</span> &gt; 60 &amp;&amp; <span class="hljs-variable">$7</span>~/\.php/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -<span class="hljs-keyword">n</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -100<br></code></pre></td></tr></table></figure><br>15、列出传输时间超过 30 秒的文件<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> www.access.<span class="hljs-keyword">log</span> |awk &#x27;(<span class="hljs-variable">$NF</span> &gt; 30)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -<span class="hljs-keyword">n</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -20<br></code></pre></td></tr></table></figure><br>16、列出当前服务器每一进程运行的数量，倒序排列<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">ps -ef | <span class="hljs-type">awk</span> -F &#x27; &#x27; &#x27;&#123;print $<span class="hljs-number">8</span> <span class="hljs-string">&quot; &quot;</span> $<span class="hljs-number">9</span>&#125;&#x27; |<span class="hljs-type">sort</span> | <span class="hljs-type">uniq</span> -c |<span class="hljs-type">sort</span> -nr |<span class="hljs-type">head</span> <span class="hljs-number">-20</span><br></code></pre></td></tr></table></figure><br>17、查看apache当前并发访问数<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">对比httpd.conf中MaxClients的数字差距多少<br>netstat -an | <span class="hljs-type">grep</span> ESTABLISHED | <span class="hljs-type">wc</span> -l<br></code></pre></td></tr></table></figure><br>18、可以使用如下参数查看数据<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs coq">ps -ef|<span class="hljs-type">grep</span> httpd|<span class="hljs-type">wc</span> -l<br><br><span class="hljs-number">1388</span><br>统计httpd进程数，连个请求会启动一个进程，使用于Apache服务器。<br>表示Apache能够处理<span class="hljs-number">1388</span>个并发请求，这个值Apache可根据负载情况自动调整<br><br>netstat -nat|<span class="hljs-type">grep</span> -i <span class="hljs-string">&quot;80&quot;</span>|<span class="hljs-type">wc</span> -l<br><br><span class="hljs-number">4341</span><br>netstat -an会打印系统当前网络链接状态，而grep -i <span class="hljs-string">&quot;80&quot;</span>是用来提取与<span class="hljs-number">80</span>端口有关的连接的，wc -l进行连接数统计。<br>最终返回的数字就是当前所有<span class="hljs-number">80</span>端口的请求总数<br><br>netstat -na|<span class="hljs-type">grep</span> ESTABLISHED|<span class="hljs-type">wc</span> -l<br><br><span class="hljs-number">376</span><br>netstat -an会打印系统当前网络链接状态，而grep ESTABLISHED 提取出已建立连接的信息。 然后wc -l统计<br>最终返回的数字就是当前所有<span class="hljs-number">80</span>端口的已建立连接的总数。<br><br>netstat -nat|<span class="hljs-type">|grep</span> ESTABLISHED|<span class="hljs-type">wc</span><br><br>可查看所有建立连接的详细记录<br></code></pre></td></tr></table></figure><br>19、输出每个ip的连接数，以及总的各个状态的连接数<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">netstat -n | awk &#x27;/^tcp/ &#123;n=<span class="hljs-built_in">split</span>($(NF-<span class="hljs-number">1</span>),<span class="hljs-built_in">array</span>,<span class="hljs-string">&quot;:&quot;</span>);<span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)++S[<span class="hljs-built_in">array</span>[(<span class="hljs-number">1</span>)]];<span class="hljs-keyword">else</span>++S[<span class="hljs-built_in">array</span>[(<span class="hljs-number">4</span>)]];++s[$NF];++N&#125; END &#123;<span class="hljs-keyword">for</span>(a <span class="hljs-keyword">in</span> S)&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s\n&quot;</span>, a, S[a]);++I&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s\n&quot;</span>,<span class="hljs-string">&quot;TOTAL_IP&quot;</span>,I);<span class="hljs-keyword">for</span>(a <span class="hljs-keyword">in</span> s) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s\n&quot;</span>,a, s[a]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %s\n&quot;</span>,<span class="hljs-string">&quot;TOTAL_LINK&quot;</span>,N);&#125;&#x27;<br></code></pre></td></tr></table></figure><br>20、其他的收集</p><p>分析日志文件下 2012-05-04 访问页面最高 的前20个 URL 并排序<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> access.<span class="hljs-built_in">log</span> |<span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;04/May/2012&#x27;</span>| awk <span class="hljs-string">&#x27;&#123;print $11&#125;&#x27;</span>|<span class="hljs-keyword">sort</span>|uniq -<span class="hljs-keyword">c</span>|<span class="hljs-keyword">sort</span> -nr|head -<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><br>查询受访问页面的URL地址中 含有 <a href="http://www.abc.com">www.abc.com</a> 网址的 IP 地址<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> access_log | awk &#x27;(<span class="hljs-variable">$11</span>~/\www.abc.com/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr<br></code></pre></td></tr></table></figure><br>获取访问最高的10个IP地址 同时也可以按时间来查询<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> linewow-access.<span class="hljs-keyword">log</span>|awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -10<br></code></pre></td></tr></table></figure><br>时间段查询日志时间段的情况<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">cat log_file | <span class="hljs-type">egrep</span> &#x27;<span class="hljs-number">15</span>/Aug/<span class="hljs-number">2015</span>|<span class="hljs-type">16</span>/Aug/<span class="hljs-number">2015</span>&#x27; |<span class="hljs-type">awk</span> &#x27;&#123;print $<span class="hljs-number">1</span>&#125;&#x27;|<span class="hljs-type">sort</span>|<span class="hljs-type">uniq</span> -c|<span class="hljs-type">sort</span> -nr|<span class="hljs-type">head</span> <span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure><br>分析2015/8/15 到 2015/8/16 访问”<code>`</code>/index.php?g=Member&amp;m=Public&amp;a=sendValidCode”的IP倒序排列<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> log_file | egrep &#x27;15/Aug/2015|16/Aug/2015&#x27; | awk &#x27;&#123;<span class="hljs-keyword">if</span>(<span class="hljs-variable">$7</span> == <span class="hljs-string">&quot;/index.php?g=Member&amp;m=Public&amp;a=sendValidCode&quot;</span>) <span class="hljs-keyword">print</span> <span class="hljs-variable">$1</span>,<span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr<br><br>(<span class="hljs-variable">$7</span>~/.php/) <span class="hljs-variable">$7</span>里面包含.php的就输出,本句的意思是最耗时的一百个PHP页面<br><br><span class="hljs-keyword">cat</span> log_file |awk &#x27;(<span class="hljs-variable">$7</span>~/\.php/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$NF</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$1</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$4</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -nr|head -100<br></code></pre></td></tr></table></figure><br>列出最最耗时的页面(超过60秒的)的以及对应页面发生次数<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> access.<span class="hljs-keyword">log</span> |awk &#x27;(<span class="hljs-variable">$NF</span> &gt; 60 &amp;&amp; <span class="hljs-variable">$7</span>~/\.php/)&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$7&#125;</span>&#x27;|<span class="hljs-keyword">sort</span> -<span class="hljs-keyword">n</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -100<br></code></pre></td></tr></table></figure><br>统计网站流量（G)<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> access.<span class="hljs-keyword">log</span> |awk &#x27;&#123;<span class="hljs-keyword">sum</span>+=<span class="hljs-variable">$10&#125;</span> END &#123;<span class="hljs-keyword">print</span> <span class="hljs-keyword">sum</span>/1024/1024/1024&#125;&#x27;<br></code></pre></td></tr></table></figure><br>统计404的连接<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">awk</span> <span class="hljs-string">&#x27;(<span class="hljs-variable">$9</span> ~/404/)&#x27;</span> access.log | awk <span class="hljs-string">&#x27;&#123;print <span class="hljs-variable">$9</span>,<span class="hljs-variable">$7</span>&#125;&#x27;</span> | sort<br></code></pre></td></tr></table></figure><br>统计http status<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> access.<span class="hljs-keyword">log</span> |awk &#x27;&#123;counts[$(9)]+=1&#125;; END &#123;<span class="hljs-keyword">for</span>(code <span class="hljs-keyword">in</span> counts) <span class="hljs-keyword">print</span> code, counts[code]&#125;&#x27; <br><span class="hljs-keyword">cat</span> access.<span class="hljs-keyword">log</span> |awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$9&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -rn<br></code></pre></td></tr></table></figure><br>每秒并发<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">watch</span> <span class="hljs-string">&quot;awk &#x27;&#123;if(<span class="hljs-variable">$9</span>~/200|30|404/)COUNT[<span class="hljs-variable">$4</span>]++&#125;END&#123;for( a in COUNT) print a,COUNT[a]&#125;&#x27; log_file|sort -k 2 -nr|head -n10&quot;</span><br></code></pre></td></tr></table></figure><br>带宽统计<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cat</span> apache.<span class="hljs-keyword">log</span> |awk &#x27;&#123;<span class="hljs-keyword">if</span>(<span class="hljs-variable">$7</span>~/GET/) <span class="hljs-keyword">count</span>++&#125;END&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;client_request=&quot;</span><span class="hljs-keyword">count</span>&#125;&#x27; <br><span class="hljs-keyword">cat</span> apache.<span class="hljs-keyword">log</span> |awk &#x27;&#123;BYTE+=<span class="hljs-variable">$11&#125;</span>END&#123;<span class="hljs-keyword">print</span> <span class="hljs-string">&quot;client_kbyte_out=&quot;</span>BYTE/1024<span class="hljs-string">&quot;KB&quot;</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><br>找出某天访问次数最多的10个IP<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">cat /tmp/access.log | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;20/Mar/2011&quot;</span> |<span class="hljs-type">awk</span> &#x27;&#123;print $<span class="hljs-number">3</span>&#125;&#x27;|<span class="hljs-type">sort</span> |<span class="hljs-type">uniq</span> -c|<span class="hljs-type">sort</span> -nr|<span class="hljs-type">head</span><br></code></pre></td></tr></table></figure><br>当天ip连接数最高的ip都在干些什么<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">cat access.log | <span class="hljs-type">grep</span> <span class="hljs-string">&quot;10.0.21.17&quot;</span> | <span class="hljs-type">awk</span> &#x27;&#123;print $<span class="hljs-number">8</span>&#125;&#x27; | <span class="hljs-type">sort</span> | <span class="hljs-type">uniq</span> -c | <span class="hljs-type">sort</span> -nr | <span class="hljs-type">head</span> -n <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><br>小时单位里ip连接数最多的10个时段<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">awk</span> -vFS=<span class="hljs-string">&quot;[:]&quot;</span> &#x27;&#123;gsub(<span class="hljs-string">&quot;-.*&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,$<span class="hljs-number">1</span>);num[$<span class="hljs-number">2</span><span class="hljs-string">&quot; &quot;</span>$<span class="hljs-number">1</span>]++&#125;END&#123;for(i in num)print i,num[i]&#125;&#x27; log_file | sort -n -k <span class="hljs-number">3</span> -r | head -<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><br>找出访问次数最多的几个分钟<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> access.log | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;20/Mar/2011&quot;</span> |cut -c <span class="hljs-number">14</span>-<span class="hljs-number">18</span>|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head<br>取<span class="hljs-number">5</span>分钟日志<br><span class="hljs-keyword">if</span> [ $DATE_MINUTE != $DATE_END_MINUTE ] ;then <span class="hljs-comment">#则判断开始时间戳与结束时间戳是否相等</span><br>START_LINE=sed -n <span class="hljs-string">&quot;/$DATE_MINUTE/=&quot;</span> $APACHE_LOG|head -n1 <span class="hljs-comment">#如果不相等，则取出开始时间戳的行号，与结束时间戳的行号</span><br></code></pre></td></tr></table></figure><br>查看tcp的链接状态<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs stata">netstat -nat |awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$6&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -rn <br>    <br>netstat -<span class="hljs-keyword">n</span> | awk &#x27;/^tcp/ &#123;++S[<span class="hljs-variable">$NF</span>]&#125;;END &#123;<span class="hljs-keyword">for</span>(a <span class="hljs-keyword">in</span> S) <span class="hljs-keyword">print</span> a, S[a]&#125;&#x27; <br><br>netstat -<span class="hljs-keyword">n</span> | awk &#x27;/^tcp/ &#123;++state[<span class="hljs-variable">$NF</span>]&#125;; END &#123;<span class="hljs-keyword">for</span>(key <span class="hljs-keyword">in</span> state) <span class="hljs-keyword">print</span> key,<span class="hljs-string">&quot;\t&quot;</span>,state[key]&#125;&#x27; <br>    <br>netstat -<span class="hljs-keyword">n</span> | awk &#x27;/^tcp/ &#123;++arr[<span class="hljs-variable">$NF</span>]&#125;;END &#123;<span class="hljs-keyword">for</span>(k <span class="hljs-keyword">in</span> arr) <span class="hljs-keyword">print</span> k,<span class="hljs-string">&quot;\t&quot;</span>,arr[k]&#125;&#x27; <br>    <br>netstat -<span class="hljs-keyword">n</span> |awk &#x27;/^tcp/ &#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$NF&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -rn <br>    <br>netstat -ant | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$NF&#125;</span>&#x27; | grep -v &#x27;[a-z]&#x27; | <span class="hljs-keyword">sort</span> | uniq -c<br>netstat -ant|awk &#x27;/ip:80/&#123;<span class="hljs-keyword">split</span>(<span class="hljs-variable">$5</span>,ip,<span class="hljs-string">&quot;:&quot;</span>);++S[ip[1]]&#125;END&#123;<span class="hljs-keyword">for</span> (a <span class="hljs-keyword">in</span> S) <span class="hljs-keyword">print</span> S[a],a&#125;&#x27; |<span class="hljs-keyword">sort</span> -<span class="hljs-keyword">n</span> <br>    <br>netstat -ant|awk &#x27;/:80/&#123;<span class="hljs-keyword">split</span>(<span class="hljs-variable">$5</span>,ip,<span class="hljs-string">&quot;:&quot;</span>);++S[ip[1]]&#125;END&#123;<span class="hljs-keyword">for</span> (a <span class="hljs-keyword">in</span> S) <span class="hljs-keyword">print</span> S[a],a&#125;&#x27; |<span class="hljs-keyword">sort</span> -rn|head -<span class="hljs-keyword">n</span> 10 <br>    <br>awk &#x27;BEGIN&#123;printf (<span class="hljs-string">&quot;http_code\tcount_num\n&quot;</span>)&#125;&#123;<span class="hljs-keyword">COUNT</span>[<span class="hljs-variable">$10</span>]++&#125;END&#123;<span class="hljs-keyword">for</span> (a <span class="hljs-keyword">in</span> <span class="hljs-keyword">COUNT</span>) printf a<span class="hljs-string">&quot;\t\t&quot;</span><span class="hljs-keyword">COUNT</span>[a]<span class="hljs-string">&quot;\n&quot;</span>&#125;&#x27;<br>查找请求数前20个IP（常用于查找攻来源）： <br>netstat -anlp|grep 80|grep tcp|awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$5&#125;</span>&#x27;|awk -F: &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -nr|head -n20 <br>netstat -ant |awk &#x27;/:80/&#123;<span class="hljs-keyword">split</span>(<span class="hljs-variable">$5</span>,ip,<span class="hljs-string">&quot;:&quot;</span>);++A[ip[1]]&#125;END&#123;<span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> A) <span class="hljs-keyword">print</span> A[i],i&#125;&#x27; |<span class="hljs-keyword">sort</span> -rn|head -n20<br><br>用tcpdump嗅探80端口的访问看看谁最高<br><br>tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F<span class="hljs-string">&quot;.&quot;</span> &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1</span><span class="hljs-string">&quot;.&quot;</span><span class="hljs-variable">$2</span><span class="hljs-string">&quot;.&quot;</span><span class="hljs-variable">$3</span><span class="hljs-string">&quot;.&quot;</span><span class="hljs-variable">$4&#125;</span>&#x27; | <span class="hljs-keyword">sort</span> | uniq -c | <span class="hljs-keyword">sort</span> -nr |head -20<br><br>查找较多time_wait连接<br><br>netstat -<span class="hljs-keyword">n</span>|grep TIME_WAIT|awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$5&#125;</span>&#x27;|<span class="hljs-keyword">sort</span>|uniq -c|<span class="hljs-keyword">sort</span> -rn|head -n20<br><br>找查较多的SYN连接<br><br>netstat -<span class="hljs-keyword">an</span> | grep SYN | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$5&#125;</span>&#x27; | awk -F: &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; | <span class="hljs-keyword">sort</span> | uniq -c | <span class="hljs-keyword">sort</span> -nr | <span class="hljs-keyword">more</span><br><br>根据端口列进程 <br>netstat -ntlp | grep 80 | awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$7&#125;</span>&#x27; | cut -<span class="hljs-keyword">d</span>/ -f1<br><br>查看了连接数和当前的连接数<br><br>netstat -ant | grep <span class="hljs-variable">$ip</span>:80 | wc -<span class="hljs-keyword">l</span> <br>netstat -ant | grep <span class="hljs-variable">$ip</span>:80 | grep <span class="hljs-keyword">EST</span> | wc -<span class="hljs-keyword">l</span><br><br>查看IP访问次数 <br>netstat -nat|grep <span class="hljs-string">&quot;:80&quot;</span>|awk &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$5&#125;</span>&#x27; |awk -F: &#x27;&#123;<span class="hljs-keyword">print</span> <span class="hljs-variable">$1&#125;</span>&#x27; | <span class="hljs-keyword">sort</span>| uniq -c|<span class="hljs-keyword">sort</span> -<span class="hljs-keyword">n</span><br><br>Linux命令分析当前的链接状况<br>netstat -<span class="hljs-keyword">n</span> | awk &#x27;/^tcp/ &#123;++S[<span class="hljs-variable">$NF</span>]&#125; END &#123;<span class="hljs-keyword">for</span>(a <span class="hljs-keyword">in</span> S) <span class="hljs-keyword">print</span> a, S[a]&#125;&#x27;<br><br>watch <span class="hljs-string">&quot;netstat -n | awk &#x27;/^tcp/ &#123;++S[\$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;&quot;</span> # 通过watch可以一直监控<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个逻辑的上的问题</title>
    <link href="/2017/06/23/%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E7%9A%84%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2017/06/23/%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E7%9A%84%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题场景："><a href="#问题场景：" class="headerlink" title="问题场景："></a>问题场景：</h2><p>调用一个api执行sql,返回执行成功。<br>如：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">执行前结果：<br><span class="hljs-keyword">table</span><br>id  <span class="hljs-keyword">test</span>    dated<br>1    0     2017-06-22  <br></code></pre></td></tr></table></figure><br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">执行的sql: <span class="hljs-keyword">update</span> table <span class="hljs-keyword">set</span> <span class="hljs-symbol">`test`</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-symbol">`dated`</span> = <span class="hljs-string">&#x27;2017-06-23&#x27;</span> <span class="hljs-keyword">where</span> <span class="hljs-symbol">`id`</span> =<span class="hljs-number">1</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">执行后结果：<br>id  test    dated<br>1    0     2017<span class="hljs-string">-06</span><span class="hljs-string">-23</span>  <br></code></pre></td></tr></table></figure></p><p>如果手动执行sql:<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">执行后结果：<br>id  test    dated<br>1    1     2017<span class="hljs-string">-06</span><span class="hljs-string">-23</span>  <br></code></pre></td></tr></table></figure></p><h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><ol><li>查binlog<br>sql是正常执行的</li></ol><p>2.发现执行sql的同时，执行了另一条sql<br><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> table <span class="hljs-keyword">set</span> <span class="hljs-symbol">`test`</span> = <span class="hljs-number">0</span> <span class="hljs-keyword">where</span> <span class="hljs-symbol">`id`</span> =<span class="hljs-number">1</span> <span class="hljs-keyword">limit</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><br>执行的原因是：因为消息系统。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推理过程：A =&gt; B =&gt; C<br>我们经常看到从A =&gt; C的过程，感觉很纳闷。<br>其实过程中，B常常是被忽略的，所以需要着重注意一下。</p>]]></content>
    
    
    
    <tags>
      
      <tag>逻辑 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 和 Memcached 的区别</title>
    <link href="/2017/06/23/Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2017/06/23/Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本描述"><a href="#一、基本描述" class="headerlink" title="一、基本描述"></a>一、基本描述</h2><p>redis与memcached相比，比仅支持简单的key-value数据类型，同时还提供list,set,zset,hash等数据结构的存储；<br>redis支持数据的备份，即master-slave模式的数据备份；<br>redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用等等，</p><h2 id="二、网络IO模型"><a href="#二、网络IO模型" class="headerlink" title="二、网络IO模型"></a>二、网络IO模型</h2><p>memcached是多线程，非阻塞IO复用的网络模型，分为监听主线程和worker子线程，监听线程监听网络连接，接受请求后，将连接描述字pipe传递给worker线程，进行读写IO，网络层使用libevent封装的事件库，多线程模型可以发挥多核作用，但是引入了cache coherency和锁的问题，比如：memcached最常用的stats命令，实际memcached所有操作都要对这个全局变量加锁，进行技术等工作，带来了性能损耗。</p><p>redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll, kqueue和select，对于单存只有IO操作来说，单线程可以将速度优势发挥到最大，但是redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型施加会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞的。</p><h2 id="三、数据支持类型"><a href="#三、数据支持类型" class="headerlink" title="三、数据支持类型"></a>三、数据支持类型</h2><p>memcached使用key-value形式存储和访问数据，在内存中维护一张巨大的HashTable，使得对数据查询的时间复杂度降低到O(1)，保证了对数据的高性能访问。</p><p>正如开篇所说：redis与memcached相比，比仅支持简单的key-value数据类型，同时还提供list,set,zset,hash等数据结构的存储；</p><p>内存管理机制</p><p>对于像Redis和Memcached这种基于内存的数据库系统来说，内存管理的效率高低是影响系统性能的关键因素。传统C语言中的malloc/free函数是最常用的分配和释放内存的方法，但是这种方法存在着很大的缺陷：首先，对于开发人员来说不匹配的malloc和free容易造成内存泄露；其次频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率；最后作为系统调用，其系统开销远远大于一般函数调用。所以，为了提高内存的管理效率，高效的内存管理方案都不会直接使用malloc/free调用。Redis和Memcached均使用了自身设计的内存管理机制，但是实现方法存在很大的差异，下面将会对两者的内存管理机制分别进行介绍。</p><p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。Slab Allocation机制只为存储外部数据而设计，也就是说所有的key-value数据都存储在Slab Allocation系统里，而Memcached的其它内存请求则通过普通的malloc/free来申请，因为这些请求的数量和频率决定了它们不会对整个系统的性能造成影响Slab Allocation的原理相当简单。 如图所示，它首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class。其中，Chunk就是用来存储key-value数据的最小单位。每个Slab Class的大小，可以在Memcached启动的时候通过制定Growth Factor来控制。假定图中Growth Factor的取值为1.25，如果第一组Chunk的大小为88个字节，第二组Chunk的大小就为112个字节，依此类推。</p><p><img src="http://img.blog.csdn.net/20160413201307553" alt></p><p>当Memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中。从以上过程我们可以看出Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。如图 所示，将100个字节的数据缓存到128个字节的Chunk中，剩余的28个字节就浪费掉了。</p><p><img src="http://img.blog.csdn.net/20160413201331287" alt></p><p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。如图所示，real_ptr是redis调用malloc后返回的指针。redis将内存块的大小size存入头部，size所占据的内存大小是已知的，为size_t类型的长度，然后返回ret_ptr。当需要释放内存的时候，ret_ptr被传给内存管理程序。通过ret_ptr，程序可以很容易的算出real_ptr的值，然后将real_ptr传给free释放内存。</p><p><img src="http://img.blog.csdn.net/20160413201348490" alt></p><p>Redis通过定义一个数组来记录所有的内存分配情况，这个数组的长度为ZMALLOC_MAX_ALLOC_STAT。数组的每一个元素代表当前程序所分配的内存块的个数，且内存块的大小为该元素的下标。在源码中，这个数组为zmalloc_allocations。zmalloc_allocations[16]代表已经分配的长度为16bytes的内存块的个数。zmalloc.c中有一个静态变量used_memory用来记录当前分配的内存总大小。所以，总的来看，Redis采用的是包装的mallc/free，相较于Memcached的内存管理方法来说，要简单很多。</p><p>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。当然，机器本身的内存必须要能够保持所有的key，毕竟这些数据是不会进行swap操作的。同时由于Redis将内存中的数据swap到磁盘中的时候，提供服务的主线程和进行swap操作的子线程会共享这部分内存，所以如果更新需要swap的数据，Redis将阻塞这个操作，直到子线程完成swap操作后才可以进行修改。当从Redis中读取数据的时候，如果读取的key对应的value不在内存中，那么Redis就需要从swap文件中加载相应数据，然后再返回给请求方。 这里就存在一个I/O线程池的问题。在默认的情况下，Redis会出现阻塞，即完成所有的swap文件加载后才会相应。这种策略在客户端的数量较小，进行批量操作的时候比较合适。但是如果将Redis应用在一个大型的网站应用程序中，这显然是无法满足大并发的情况的。所以Redis运行我们设置I/O线程池的大小，对需要从swap文件中加载相应数据的读取请求进行并发操作，减少阻塞的时间。</p><p>Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除，原因可以参考Timyang的文章：<a href="http://timyang.net/data/Memcached-lru-evictions/">http://timyang.net/data/Memcached-lru-evictions/</a></p><p>Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据（但会尝试剔除部分临时数据），这点上Redis更适合作为存储而不是cache。</p><h2 id="五、数据存储及持久化"><a href="#五、数据存储及持久化" class="headerlink" title="五、数据存储及持久化"></a>五、数据存储及持久化</h2><p>memcached不支持内存数据的持久化操作，所有的数据都以in-memory的形式存储。</p><p>redis支持持久化操作。redis提供了两种不同的持久化方法来讲数据存储到硬盘里面，一种是快照（snapshotting)，它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件（append-only file， AOF),它会在执行写命令时，将被执行的写命令复制到硬盘里面。</p><h2 id="六、数据一致性问题"><a href="#六、数据一致性问题" class="headerlink" title="六、数据一致性问题"></a>六、数据一致性问题</h2><p>Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。</p><h2 id="七、集群管理不同"><a href="#七、集群管理不同" class="headerlink" title="七、集群管理不同"></a>七、集群管理不同</h2><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。下图给出了Memcached的分布式存储实现架构。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。Redis Cluster的分布式存储架构，节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。</p><p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>redis memcached</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CI框架中调整sql查询条件关系</title>
    <link href="/2017/06/22/CI%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%B0%83%E6%95%B4sql%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E5%85%B3%E7%B3%BB/"/>
    <url>/2017/06/22/CI%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%B0%83%E6%95%B4sql%E6%9F%A5%E8%AF%A2%E6%9D%A1%E4%BB%B6%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h2><p>sql执行的时候，查询条件并没有优先级，需要调整下。</p><h2 id="想实现的场景"><a href="#想实现的场景" class="headerlink" title="想实现的场景"></a>想实现的场景</h2><p>sql查询条件: A and B and (C or D)</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>想获取18岁，姓名为A或B的人。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">$this-&gt;db-&gt;select(<span class="hljs-string">&#x27;id&#x27;</span>)<br>-&gt;<span class="hljs-keyword">where</span>(<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-number">18</span>) <br>-&gt;group_start() <span class="hljs-comment">//左括号</span><br>-&gt;like(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)<br>-&gt;or_like(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br>-&gt;group_end() <span class="hljs-comment">//右括号</span><br>-&gt;get(<span class="hljs-string">&#x27;table&#x27;</span>);<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>CI框架 sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转]ios 绑定事件无效</title>
    <link href="/2017/06/14/%E8%BD%AC-ios-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88/"/>
    <url>/2017/06/14/%E8%BD%AC-ios-%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%97%A0%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>当使用委托给一个元素添加click事件时，如果事件是委托到 document 或 body 上，并且委托的元素是默认不可点击的（如 div, span 等），此时 click 事件会失效。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>iOS click bug test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">        &#125;</span><br><span class="css"></span><br><span class="css">        <span class="hljs-selector-class">.target</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">display</span>: block;</span><br><span class="css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> <span class="hljs-number">30px</span> <span class="hljs-number">0</span>;</span><br><span class="css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span> Click Me! <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//code.jquery.com/jquery-2.1.4.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-comment">// 或者 $(document).on(&#x27;click&#x27;, ....)</span></span><br><span class="javascript">        $(<span class="hljs-string">&#x27;body&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;.target&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">            alert(<span class="hljs-string">&#x27;click&#x27;</span>);</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>  <br></code></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法有 4 种可供选择：</p><p>​将 click 事件直接绑定到目标元素（即 .target）上<br>将目标元素换成 <a> 或者 button 等可点击的元素<br>​将 click 事件委托到非 document 或 body 的父级元素上<br>​给目标元素加一条样式规则 cursor: pointer;<br>​推荐后两种。从解决办法来看，推测在 safari 中，不可点击的元素的点击事件不会冒泡到父级元素。通过添加 cursor: pointer 使得元素变成了可点击的了。</a></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li><a href="https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html">Click event delegation on the iPhone</a></li><li><a href="https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP40006511-SW6">Making Elements Clickable</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>ios 绑定事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql binlog日志查看</title>
    <link href="/2017/06/05/mysql-binlog%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/"/>
    <url>/2017/06/05/mysql-binlog%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><ol><li><p>定义<br>binlog基本定义：二进制日志，也成为二进制日志，记录对数据发生或潜在发生更改的SQL语句，并以二进制的形式保存在磁盘中；</p></li><li><p>作用<br>可以用来查看数据库的变更历史（具体的时间点所有的SQL操作）、数据库增量备份和恢复（增量备份和基于时间点的恢复）、Mysql的复制（主主数据库的复制、主从数据库的复制）</p></li><li><p>格式<br>binlog的格式有三种，这也反应了mysql的复制技术：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，混合模式复制(mixed-based replication, MBR)。相应地，binlog的格式也有三种：STATEMENT，ROW，MIXED。</p></li><li><p>日志位置<br>修改my.cnf参数文件<br>[mysqld]<br>log-bin=mysql-bin</p></li></ol><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><ol><li>命令<br>binlog不能直接用文本的方式打开。<br>使用show binlog events方式可以获取当前以及指定binlog的日志，不适宜提取大量日志。<br>使用mysqlbinlog命令行提取(适宜批量提取日志)。</li></ol><ol start="2"><li><p>语法</p><p> 直接查看单个二进制日志文件：<br> mysqlbinlog filename</p><p> 提取指定position位置的binlog日志<br> –start-position=”120” –stop-position=”332”</p><p> 提取指定数据库binlog并转换字符集到UTF8<br> –database=test –set-charset=utf8</p><p> 指定结束时间<br> –start-datetime=’2015-01-20 09:00:00’ –stop-datetime=’2015-01-20 12:59:59’</p><p>  指定row格式解码<br> –base64-output=decode-rows </p><p> -v用于输出基于row模式的binlog日志<br> -vv为列数据类型添加注释</p></li></ol><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># at <span class="hljs-number">579744</span>（开始位置）<br><span class="hljs-meta">#150905  7:02:54（时间截） server id 2543308（产生该事件的服务id）  end_log_pos（日志的结束位置） 579815  Query（事件类型）   thread_id=21    exec_time=0     error_code=0</span><br><span class="hljs-keyword">SET</span> <span class="hljs-type">TIMESTAMP</span>=<span class="hljs-number">1441407774</span><span class="hljs-comment">/*!*/</span>;<br><span class="hljs-keyword">BEGIN</span><br>执行的<span class="hljs-keyword">sql</span>语句<br></code></pre></td></tr></table></figure><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><ol><li>在数据出错的情况下，使用 MYSQLBINLOG 来恢复数据</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mysql binlog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC中的service层是干嘛的？</title>
    <link href="/2017/05/30/MVC%E4%B8%AD%E7%9A%84service%E5%B1%82%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F/"/>
    <url>/2017/05/30/MVC%E4%B8%AD%E7%9A%84service%E5%B1%82%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>mvc框架由model，view，controller组成，执行流程一般是：在controller访问model获取数据，通过view渲染页面。</p><p>mvc模式是web开发中的基础模式，采用的是分层设计，各层之间职责分明。然而事与愿违，当我们日积月累的基于mvc模式开发之后，会逐渐的感受到层与层之间存在粘连和职责模棱两可的地方，这就是service层出现的重要原因。</p><h1 id="问题是什么？"><a href="#问题是什么？" class="headerlink" title="问题是什么？"></a>问题是什么？</h1><p>问题的本质是：业务逻辑粘连了C层和M层，应该从C层&amp;M层解耦出来，成为独立的Service层。<br>在C层直接实现业务逻辑，缺点：</p><ol><li><p>不同的controller之间，无法共享通用的业务逻辑，比如：折扣计算。</p></li><li><p>业务逻辑升级，需直接在原代码上做修改兼容，导致controller代码不断膨胀复杂。</p></li></ol><h1 id="service层的作用："><a href="#service层的作用：" class="headerlink" title="service层的作用："></a>service层的作用：</h1><p>service是业务层，是使用一个或多个模型执行操作的方法。</p><ol><li>封装通用的业务逻辑，操作。<br> 如一些数据的检验，可以通用处理。</li><li>与数据层的交互。</li><li>其他请求：如远程服务获取数据，如第三方api等。</li></ol><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><ol><li>Model和Service验证方面<br>Model校验：某些字段不能为空等数据层的校验<br>Service验证：逻辑层的校验，避免一些不合理的出现，尤其是调用多个模型</li><li>ci框架扩展service<br><a href="http://www.cnblogs.com/SLchuck/p/5804555.html">http://www.cnblogs.com/SLchuck/p/5804555.html</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>mvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议入门</title>
    <link href="/2017/05/23/HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/"/>
    <url>/2017/05/23/HTTP%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h1><h2 id="一-HTTP-0-99版本"><a href="#一-HTTP-0-99版本" class="headerlink" title="一. HTTP 0.99版本"></a>一. HTTP 0.99版本</h2><p>命令:GET<br>用法: GET /index.html<br>响应:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h2 id="二-HTTP-1-0版本"><a href="#二-HTTP-1-0版本" class="headerlink" title="二. HTTP 1.0版本"></a>二. HTTP 1.0版本</h2><ol><li>命令: GET、POST、HEAD</li><li><p>通用头部:主要用于传达关于消息本身的信息，而不是它所携带的内容。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Request URL:http:<span class="hljs-comment">//www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</span><br>Request <span class="hljs-function"><span class="hljs-keyword">Method</span>:</span>GET<br>Status Code:<span class="hljs-number">200</span> OK<br>Remote Address:<span class="hljs-number">116.251</span>.<span class="hljs-number">204.42</span>:<span class="hljs-number">80</span><br>Referrer Policy:no-referrer-when-downgrade<br></code></pre></td></tr></table></figure><p>请求格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>:text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,image/webp,*/*;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Accept</span>-Encoding:gzip, deflate, sdch<br><span class="hljs-attribute">Accept</span>-Language:zh-CN,zh;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">Cache</span>-Control:max-age=<span class="hljs-number">0</span><br><span class="hljs-attribute">Connection</span>:keep-alive<br><span class="hljs-attribute">Cookie</span>:_ga=GA<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">81864988</span>.<span class="hljs-number">1486909163</span>; _gid=GA<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">993479087</span>.<span class="hljs-number">1495547947</span><br><span class="hljs-attribute">Host</span>:www.ruanyifeng.com<br><span class="hljs-attribute">If</span>-Modified-Since:Thu, <span class="hljs-number">18</span> May <span class="hljs-number">2017</span> <span class="hljs-number">00</span>:<span class="hljs-number">37</span>:<span class="hljs-number">52</span> GMT<br><span class="hljs-attribute">If</span>-None-Match:<span class="hljs-string">&quot;3dc9a-54fc19d6cf800-gzip&quot;</span><br><span class="hljs-attribute">Referer</span>:http://www.ruanyifeng.com/blog/<span class="hljs-number">2016</span>/<span class="hljs-number">08</span>/http.html<br><span class="hljs-attribute">Upgrade</span>-Insecure-Requests:<span class="hljs-number">1</span><br><span class="hljs-attribute">User</span>-Agent:Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win<span class="hljs-number">64</span>; x<span class="hljs-number">64</span>) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">58</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3029</span>.<span class="hljs-number">96</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span>Accept-Ranges:bytes<br><span class="hljs-attribute">Connection</span>:Keep-Alive<br><span class="hljs-attribute">Content</span>-Encoding:gzip<br><span class="hljs-attribute">Content</span>-Length:<span class="hljs-number">48951</span><br><span class="hljs-attribute">Content</span>-Type:text/html<br><span class="hljs-attribute">Date</span>:Tue, <span class="hljs-number">23</span> May <span class="hljs-number">2017</span> <span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">26</span> GMT<br><span class="hljs-attribute">ETag</span>:<span class="hljs-string">&quot;3dc9a-54fc19d6cf800-gzip&quot;</span><br><span class="hljs-attribute">Keep</span>-Alive:timeout=<span class="hljs-number">5</span>, max=<span class="hljs-number">100</span><br><span class="hljs-attribute">Last</span>-Modified:Thu, <span class="hljs-number">18</span> May <span class="hljs-number">2017</span> <span class="hljs-number">00</span>:<span class="hljs-number">37</span>:<span class="hljs-number">52</span> GMT<br><span class="hljs-attribute">Server</span>:Apache<br><span class="hljs-attribute">Vary</span>:Accept-Encoding<br></code></pre></td></tr></table></figure><p>响应格式:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>-Ranges:bytes<br><span class="hljs-attribute">Connection</span>:Keep-Alive<br><span class="hljs-attribute">Content</span>-Encoding:gzip<br><span class="hljs-attribute">Content</span>-Length:<span class="hljs-number">48951</span><br><span class="hljs-attribute">Content</span>-Type:text/html<br><span class="hljs-attribute">Date</span>:Tue, <span class="hljs-number">23</span> May <span class="hljs-number">2017</span> <span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">26</span> GMT<br><span class="hljs-attribute">ETag</span>:<span class="hljs-string">&quot;3dc9a-54fc19d6cf800-gzip&quot;</span><br><span class="hljs-attribute">Keep</span>-Alive:timeout=<span class="hljs-number">5</span>, max=<span class="hljs-number">100</span><br><span class="hljs-attribute">Last</span>-Modified:Thu, <span class="hljs-number">18</span> May <span class="hljs-number">2017</span> <span class="hljs-number">00</span>:<span class="hljs-number">37</span>:<span class="hljs-number">52</span> GMT<br><span class="hljs-attribute">Server</span>:Apache<br><span class="hljs-attribute">Vary</span>:Accept-Encoding<br></code></pre></td></tr></table></figure></li><li><p>详细说明<br>Content-Encoding：数据的压缩方法<br>Content-Type:数据格式</p></li><li><p>缺点</p></li></ol><blockquote><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p></blockquote><p>解决方法：Connection: keep-alive</p><h2 id="三、-HTTP-1-1"><a href="#三、-HTTP-1-1" class="headerlink" title="三、 HTTP/1.1"></a>三、 HTTP/1.1</h2><ol><li>持久连接</li><li>管道机制</li><li>Content-Length 字段</li></ol><h1 id="HTTP基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><p>一、HTTP方法<br>|HTTP方法| 描述|<br>| :——–   | —–  |<br>|GET    |从服务器向客户端发送命名资源|<br>|PUT    |将客户端的数据存储到一个命名的服务器资源中去|<br>|DELETE |从客户端删除命名资源|<br>|POST   |将客户端数据发送到一个服务器网关应用程序|<br>|HEAD   |仅发送命名资源相应中的HTTP头部|</p><p>二、状态码<br>|整体范围|已定义范围|分类|<br>|:–:|:–:|:–:|<br>|100-199|100-101|信息提示|<br>|200-299|200-206|成功|<br>|300-399|300-305|重定向|<br>|400-499|400-415|客户端错误|<br>|500-599|500-505|服务器错误|</p><p>三、网络模型<br>|模型层次| 描述|例子<br>| :——–   | —–  |<br>|HTTP    |应用层|DHCP（v6） DNS FTP Gopher HTTP（SPDY、HTTP/2） IMAP4 IRC NNTP XMPP POP3 SIP SMTP SNMP SSH TELNET RPC RTCP RTP RTSP SDP SOAP GTP STUN NTP SSDP|<br>|TCP     |传输层|TCP（T/TCP · Fast Open） UDP DCCP SCTP RSVP PPTP TLS/SSL|<br>|IP      |网络层|IP（v4·v6） ICMP（v6） IGMP IS-IS IPsec BGP RIP OSPF RARP|<br>|链路层  |数据链路层|Wi-Fi（IEEE 802.11） ARP WiMAX（IEEE 802.16） ATM DTM 令牌环 以太网 FDDI 帧中继 GPRS EV-DO HSPA HDLC PPP PPPoE L2TP ISDN SPB STP|<br>|物理网络硬件| 物理层|以太网 调制解调器 电力线通信 同步光网络 G.709 光导纤维 同轴电缆 双绞线|</p><p>四、从输入URL到页面加载完成的过程中都发生了什么事情</p><ol><li>浏览器查找域名的IP地址:这一步包括DNS具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…</li><li>浏览器向web服务器发送一个HTTP请求;</li><li>服务器的永久重定向响应; </li><li>浏览器跟踪重定向地址; </li><li>服务器处理请求;</li><li>服务器返回一个HTTP响应; </li><li>浏览器显示HTML;</li><li>浏览器发送请求获取嵌入在HTML中的资源（如图片、音频、视频、CSS、JS等等）;</li><li>浏览器发送异步请求;</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP程序如何debug?</title>
    <link href="/2017/05/17/PHP%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95debug/"/>
    <url>/2017/05/17/PHP%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95debug/</url>
    
    <content type="html"><![CDATA[<h1 id="一、检查是否有语法错误"><a href="#一、检查是否有语法错误" class="headerlink" title="一、检查是否有语法错误"></a>一、检查是否有语法错误</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">php -l <span class="hljs-keyword">test</span>.php <br></code></pre></td></tr></table></figure><h1 id="二、基本调试"><a href="#二、基本调试" class="headerlink" title="二、基本调试"></a>二、基本调试</h1><p>基本调试 API：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">var_dump(<span class="hljs-variable">$var</span>);print_r(<span class="hljs-variable">$var</span>);<span class="hljs-built_in">echo</span> <span class="hljs-variable">$var</span>;<br></code></pre></td></tr></table></figure><br>基本的配置：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">display_errors</span>、log_errors、error_reporting、error_log<br></code></pre></td></tr></table></figure><br>备注：有时候，会关闭报错，需要手动开启。</p><p>常用代码：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">ini_set</span>(<span class="hljs-string">&quot;display_errors&quot;</span>,<span class="hljs-string">&quot;On&quot;</span>);<br><span class="hljs-selector-tag">error_reporting</span>(E_ALL);<br></code></pre></td></tr></table></figure></p><p>三、利用错误收集函数</p><p>参考手册：<a href="http://php.net/manual/zh/book.errorfunc.php">http://php.net/manual/zh/book.errorfunc.php</a></p><ul><li>debug_backtrace — 产生一条回溯跟踪(backtrace)</li><li>debug_print_backtrace — 打印一条回溯。</li><li>error_clear_last — 清除最近一次错误</li><li>error_get_last — 获取最后发生的错误</li><li>error_log — 发送错误信息到某个地方</li><li>error_reporting — 设置应该报告何种 PHP 错误</li><li>restore_error_handler — 还原之前的错误处理函数</li><li>restore_exception_handler — 恢复之前定义过的异常处理函数。</li><li>set_error_handler — 设置用户自定义的错误处理函数</li><li>set_exception_handler — 设置用户自定义的异常处理函数</li><li>trigger_error — 产生一个用户级别的 error/warning/notice 信息</li><li>user_error — trigger_error 的别名</li></ul><p>示例代码:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php">register_shutdown_function(<span class="hljs-string">&#x27;my_shutdown_handler&#x27;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">my_shutdown_handler</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-variable">$error</span> = error_get_last();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$error</span>) &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//发送邮件</span><br>        &#125; <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><h1 id="三、记log"><a href="#三、记log" class="headerlink" title="三、记log"></a>三、记log</h1><p>你认为可能出错的地方<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">file<span class="hljs-constructor">_put_contents(&#x27;<span class="hljs-params">log</span>.<span class="hljs-params">text</span>&#x27;, <span class="hljs-params">var_export</span>($<span class="hljs-params">var</span>, 1)</span>, FILE_APPEND);<br></code></pre></td></tr></table></figure><br>另外也需要配置error_log</p><p>一般是查看apache的错误日志。命令行执行的错误，并不能收集。</p><h1 id="四、IDE-调试"><a href="#四、IDE-调试" class="headerlink" title="四、IDE 调试"></a>四、IDE 调试</h1><p>在编写时就能发现一些基本的语法错误。</p><h1 id="五、使用工具-xdebug"><a href="#五、使用工具-xdebug" class="headerlink" title="五、使用工具:xdebug"></a>五、使用工具:xdebug</h1><p>xdebug_start_trace();<br>/<em> 业务代码     </em>/<br>xdebug_stop_trace();</p><p>参考：</p><ol><li>xdebug参考:<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-php-xdebug/index.html">https://www.ibm.com/developerworks/cn/opensource/os-php-xdebug/index.html</a></li><li>PhpStorm之Xdebug断点调试:<br><a href="http://www.jianshu.com/p/90a724ff85f1">http://www.jianshu.com/p/90a724ff85f1</a></li><li>PHP 调试技术手册<br><a href="http://blog.xiayf.cn/assets/uploads/files/PHP-Debug-Manual-public.pdf">http://blog.xiayf.cn/assets/uploads/files/PHP-Debug-Manual-public.pdf</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>debug php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[转]Redis 和 Memcached 的区别</title>
    <link href="/2017/05/16/%E8%BD%AC-Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2017/05/16/%E8%BD%AC-Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本描述"><a href="#一、基本描述" class="headerlink" title="一、基本描述"></a>一、基本描述</h2><p>redis与memcached相比，比仅支持简单的key-value数据类型，同时还提供list,set,zset,hash等数据结构的存储；<br>redis支持数据的备份，即master-slave模式的数据备份；<br>redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用等等，</p><h2 id="二、网络IO模型"><a href="#二、网络IO模型" class="headerlink" title="二、网络IO模型"></a>二、网络IO模型</h2><p>memcached是多线程，非阻塞IO复用的网络模型，分为监听主线程和worker子线程，监听线程监听网络连接，接受请求后，将连接描述字pipe传递给worker线程，进行读写IO，网络层使用libevent封装的事件库，多线程模型可以发挥多核作用，但是引入了cache coherency和锁的问题，比如：memcached最常用的stats命令，实际memcached所有操作都要对这个全局变量加锁，进行技术等工作，带来了性能损耗。</p><p>redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll, kqueue和select，对于单存只有IO操作来说，单线程可以将速度优势发挥到最大，但是redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型施加会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞的。</p><h2 id="三、数据支持类型"><a href="#三、数据支持类型" class="headerlink" title="三、数据支持类型"></a>三、数据支持类型</h2><p>memcached使用key-value形式存储和访问数据，在内存中维护一张巨大的HashTable，使得对数据查询的时间复杂度降低到O(1)，保证了对数据的高性能访问。</p><p>正如开篇所说：redis与memcached相比，比仅支持简单的key-value数据类型，同时还提供list,set,zset,hash等数据结构的存储；</p><p>内存管理机制</p><p>对于像Redis和Memcached这种基于内存的数据库系统来说，内存管理的效率高低是影响系统性能的关键因素。传统C语言中的malloc/free函数是最常用的分配和释放内存的方法，但是这种方法存在着很大的缺陷：首先，对于开发人员来说不匹配的malloc和free容易造成内存泄露；其次频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率；最后作为系统调用，其系统开销远远大于一般函数调用。所以，为了提高内存的管理效率，高效的内存管理方案都不会直接使用malloc/free调用。Redis和Memcached均使用了自身设计的内存管理机制，但是实现方法存在很大的差异，下面将会对两者的内存管理机制分别进行介绍。</p><p>Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录，以完全解决内存碎片问题。Slab Allocation机制只为存储外部数据而设计，也就是说所有的key-value数据都存储在Slab Allocation系统里，而Memcached的其它内存请求则通过普通的malloc/free来申请，因为这些请求的数量和频率决定了它们不会对整个系统的性能造成影响Slab Allocation的原理相当简单。 如图所示，它首先从操作系统申请一大块内存，并将其分割成各种尺寸的块Chunk，并把尺寸相同的块分成组Slab Class。其中，Chunk就是用来存储key-value数据的最小单位。每个Slab Class的大小，可以在Memcached启动的时候通过制定Growth Factor来控制。假定图中Growth Factor的取值为1.25，如果第一组Chunk的大小为88个字节，第二组Chunk的大小就为112个字节，依此类推。</p><p><img src="http://img.blog.csdn.net/20160413201307553" alt></p><p>当Memcached接收到客户端发送过来的数据时首先会根据收到数据的大小选择一个最合适的Slab Class，然后通过查询Memcached保存着的该Slab Class内空闲Chunk的列表就可以找到一个可用于存储数据的Chunk。当一条数据库过期或者丢弃时，该记录所占用的Chunk就可以回收，重新添加到空闲列表中。从以上过程我们可以看出Memcached的内存管理制效率高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。因为每个Chunk都分配了特定长度的内存空间，所以变长数据无法充分利用这些空间。如图 所示，将100个字节的数据缓存到128个字节的Chunk中，剩余的28个字节就浪费掉了。</p><p><img src="http://img.blog.csdn.net/20160413201331287" alt></p><p>Redis的内存管理主要通过源码中zmalloc.h和zmalloc.c两个文件来实现的。Redis为了方便内存的管理，在分配一块内存之后，会将这块内存的大小存入内存块的头部。如图所示，real_ptr是redis调用malloc后返回的指针。redis将内存块的大小size存入头部，size所占据的内存大小是已知的，为size_t类型的长度，然后返回ret_ptr。当需要释放内存的时候，ret_ptr被传给内存管理程序。通过ret_ptr，程序可以很容易的算出real_ptr的值，然后将real_ptr传给free释放内存。</p><p><img src="http://img.blog.csdn.net/20160413201348490" alt></p><p>Redis通过定义一个数组来记录所有的内存分配情况，这个数组的长度为ZMALLOC_MAX_ALLOC_STAT。数组的每一个元素代表当前程序所分配的内存块的个数，且内存块的大小为该元素的下标。在源码中，这个数组为zmalloc_allocations。zmalloc_allocations[16]代表已经分配的长度为16bytes的内存块的个数。zmalloc.c中有一个静态变量used_memory用来记录当前分配的内存总大小。所以，总的来看，Redis采用的是包装的mallc/free，相较于Memcached的内存管理方法来说，要简单很多。</p><p>在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。当物理内存用完时，Redis可以将一些很久没用到的value交换到磁盘。Redis只会缓存所有的key的信息，如果Redis发现内存的使用量超过了某一个阀值，将触发swap的操作，Redis根据“swappability = age*log(size_in_memory)”计算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。当然，机器本身的内存必须要能够保持所有的key，毕竟这些数据是不会进行swap操作的。同时由于Redis将内存中的数据swap到磁盘中的时候，提供服务的主线程和进行swap操作的子线程会共享这部分内存，所以如果更新需要swap的数据，Redis将阻塞这个操作，直到子线程完成swap操作后才可以进行修改。当从Redis中读取数据的时候，如果读取的key对应的value不在内存中，那么Redis就需要从swap文件中加载相应数据，然后再返回给请求方。 这里就存在一个I/O线程池的问题。在默认的情况下，Redis会出现阻塞，即完成所有的swap文件加载后才会相应。这种策略在客户端的数量较小，进行批量操作的时候比较合适。但是如果将Redis应用在一个大型的网站应用程序中，这显然是无法满足大并发的情况的。所以Redis运行我们设置I/O线程池的大小，对需要从swap文件中加载相应数据的读取请求进行并发操作，减少阻塞的时间。</p><p>Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除，原因可以参考Timyang的文章：<a href="http://timyang.net/data/Memcached-lru-evictions/">http://timyang.net/data/Memcached-lru-evictions/</a></p><p>Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据（但会尝试剔除部分临时数据），这点上Redis更适合作为存储而不是cache。</p><h2 id="五、数据存储及持久化"><a href="#五、数据存储及持久化" class="headerlink" title="五、数据存储及持久化"></a>五、数据存储及持久化</h2><p>memcached不支持内存数据的持久化操作，所有的数据都以in-memory的形式存储。</p><p>redis支持持久化操作。redis提供了两种不同的持久化方法来讲数据存储到硬盘里面，一种是快照（snapshotting)，它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件（append-only file， AOF),它会在执行写命令时，将被执行的写命令复制到硬盘里面。</p><h2 id="六、数据一致性问题"><a href="#六、数据一致性问题" class="headerlink" title="六、数据一致性问题"></a>六、数据一致性问题</h2><p>Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。</p><h2 id="七、集群管理不同"><a href="#七、集群管理不同" class="headerlink" title="七、集群管理不同"></a>七、集群管理不同</h2><p>Memcached是全内存的数据缓冲系统，Redis虽然支持数据的持久化，但是全内存毕竟才是其高性能的本质。作为基于内存的存储系统来说，机器物理内存的大小就是系统能够容纳的最大数据量。如果需要处理的数据量超过了单台机器的物理内存大小，就需要构建分布式集群来扩展存储能力。</p><p>Memcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。下图给出了Memcached的分布式存储实现架构。当客户端向Memcached集群发送数据之前，首先会通过内置的分布式算法计算出该条数据的目标节点，然后数据会直接发送到该节点上存储。但客户端查询数据时，同样要计算出查询数据所在的节点，然后直接向该节点发送查询请求以获取数据。</p><p>相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。最新版本的Redis已经支持了分布式存储功能。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。Redis Cluster的分布式存储架构，节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。</p><p>为了保证单点故障下的数据可用性，Redis Cluster引入了Master节点和Slave节点。在Redis Cluster中，每个Master节点都会有对应的两个用于冗余的Slave节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当Master节点退出后，集群会自动选择一个Slave节点成为新的Master节点。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis Memcached</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在postman中调用自定义签名方式的API</title>
    <link href="/2017/05/16/%E5%9C%A8postman%E4%B8%AD%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%BE%E5%90%8D%E6%96%B9%E5%BC%8F%E7%9A%84API/"/>
    <url>/2017/05/16/%E5%9C%A8postman%E4%B8%AD%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AD%BE%E5%90%8D%E6%96%B9%E5%BC%8F%E7%9A%84API/</url>
    
    <content type="html"><![CDATA[<p>###一、目的<br>    项目内部api接口使用的签名方式导致在postman中不能使用，需要在postman中，自行实现签名方式以方便测试API接口。</p><p>###二、实现原理</p><pre><code>1. 在postman实际调用接口前，可以执行自定义js，从而实现数据签名2. 自定义JS可以获取到请求参数、链接参数，并且可以自定义变量</code></pre><p>###三、接口调用</p><pre><code>1. Params:链接中的通用参数2. Headers:请求头一般不需要处理3. Pre-request script:预执行脚本<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> <span class="hljs-built_in">str</span> = <span class="hljs-number">1</span>;<br>postman.setGlobalVariable(<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure>4. Body:接口post参数 数据类型一般选择from-data</code></pre><p>###四、环境变量的切换</p><p>####变量</p><ol><li>环境变量：EnvironmentVariable<br>在整个environment内都可以用<br>ps:在预执行脚本中，需要用environment.变量名来获取，不能执行获取到</li><li>全局变量：GlobalVariable<br>可以在任意环境下使用<br>ps:预执行脚本中定义的变量并不能在url、params使用<br>原因是因为拼接在预执行脚本之前<br>单在body里又是可以用的，数据组装在预执行脚本代码之后</li><li>自定义变量：<br>仅能在预执行脚本中用</li></ol><p>###环境管理</p><pre><code>1. 可以将不同环境的变量定义在环境变量中2. 在url、params、body中的数据，预执行脚本等地方使用</code></pre><p>###接口调用</p><pre><code>1. 选择环境2. 接口地址、参数等使用环境变量&#123;&#123;变量名&#125;&#125;3.添加接口特定参数</code></pre><p>###添加预执行脚本</p>]]></content>
    
    
    
    <tags>
      
      <tag>api postman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TED演讲：脆弱的关系</title>
    <link href="/2017/05/14/TED%E6%BC%94%E8%AE%B2%EF%BC%9A%E8%84%86%E5%BC%B1%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2017/05/14/TED%E6%BC%94%E8%AE%B2%EF%BC%9A%E8%84%86%E5%BC%B1%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="研究主题：关系的简单介绍"><a href="#研究主题：关系的简单介绍" class="headerlink" title="研究主题：关系的简单介绍"></a>研究主题：关系的简单介绍</h1><ol><li>关系很重要<br>关系是我们活着的原因，它赋予了我们生命的意思。<br>我们也愿意和别人建立亲密的关系。</li><li>关系也带来脆弱<br>————“你做的不够好”<br>————“你不漂亮”<br>————“你很胖”<br>————“你职位不够高”<br>“耻辱感”都是别人“强加”来的，然后我们自以为我们就是那样的。<br>虽然有时候会带来耻辱感，我们却不能断绝关系，因为要想产生关系，我们必须让自己被看见。</li><li>王小波说: 人的一切痛苦,本质上都是对自己无能的愤怒。<br>难道就因为我们脆弱，所以就只能这样自暴自弃了？</li></ol><h1 id="研究对象对比：我不够好-vs-我够好"><a href="#研究对象对比：我不够好-vs-我够好" class="headerlink" title="研究对象对比：我不够好 vs 我够好"></a>研究对象对比：我不够好 vs 我够好</h1><ol><li>我够好的人：具有自我价值感的人<br>他们勇敢去爱并且拥有强烈的归属感<br>他们相信自己值得被爱，他们相信自己的价值。</li><li>我不够好的人：在苦苦挣扎<br>他们不相信自己的价值，讨厌给别人添麻烦。</li></ol><h1 id="研究结果："><a href="#研究结果：" class="headerlink" title="研究结果："></a>研究结果：</h1><ol><li><p>具有自我价值感的人是怎么样的？</p><ul><li>他们有勇气承认自己的不完美。</li><li>他们坦诚，愿意放开自己设定的那个理想的自我，以换取真正的自我。</li><li>他们接受自己的脆弱。</li></ul></li><li><p>我们活在一个脆弱的世界，我们麻痹脆弱。</p><ul><li>我们麻痹不了情感（我不想要痛苦的情感），我们必须去只面它们。</li><li>我们把不确定，变成确定。确定性给我们带来安全感。</li><li>我们越害怕，我们越脆弱。</li></ul></li><li><p>我们也想让自己变得完美，我们去整容，去抽脂。我们想要我们的孩子变得完美。生一个完美的孩子，不是我们的任务。而是让还在接受不完美，但是你仍然值得被爱。</p></li><li><p>我们在假装我们的行为，不会影响他人。<br>（正是因为谎言，我们才变得如此脆弱？）</p></li></ol><h1 id="参考意义"><a href="#参考意义" class="headerlink" title="参考意义"></a>参考意义</h1><ol><li>卸下我们的面具，才能让我们被看见。</li><li>接受不完美，我们已经够好了。</li><li>真正的朋友，不需要担心去带给别人。</li></ol><h1 id="逻辑主线的变化"><a href="#逻辑主线的变化" class="headerlink" title="逻辑主线的变化"></a>逻辑主线的变化</h1><p>演讲者讨厌消极的情感，讨厌脆弱的关系，是我们为自我价值而挣扎的根源。<br>=&gt; 正因为脆弱，我们才会互相依赖，我们才会有欢乐、创造性、感恩、爱……</p><h1 id="查看更多："><a href="#查看更多：" class="headerlink" title="查看更多："></a>查看更多：</h1><p><a href="https://www.ted.com/talks/brene_brown_on_vulnerability?language=zh-cn">https://www.ted.com/talks/brene_brown_on_vulnerability?language=zh-cn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>关系 阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HIT训练</title>
    <link href="/2017/05/08/HIT%E8%AE%AD%E7%BB%83/"/>
    <url>/2017/05/08/HIT%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<ol><li>20秒的剧烈运动，每次3轮共60秒，每周3次共3分钟。<br>每次3轮+休息的时间 = 一首歌的时间<br>可以边听歌，边运动。</li><li>经常走动，不要久坐。<br>久坐不要超过1小时</li></ol><p>视频地址：<a href="http://player.youku.com/embed/XMTU1MjU1NDk2MA==">http://player.youku.com/embed/XMTU1MjU1NDk2MA==</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql处理海量数据时的一些优化查询速度方法</title>
    <link href="/2017/05/07/mysql%E5%A4%84%E7%90%86%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E6%96%B9%E6%B3%95/"/>
    <url>/2017/05/07/mysql%E5%A4%84%E7%90%86%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>最近一段时间由于工作需要，开始关注针对Mysql数据库的select查询语句的相关优化方法。</p><p>由于在参与的实际项目中发现当mysql表的数据量达到百万级时，普通SQL查询效率呈直线下降，而且如果where中的查询条件较多时，其查询速度简直无法容忍。曾经测试对一个包含400多万条记录（有索引）的表执行一条条件查询，其查询时间竟然高达40几秒，相信这么高的查询延时，任何用户都会抓狂。因此如何提高sql语句查询效率，显得十分重要。以下是网上流传比较广泛的30种SQL查询语句优化方法：</p><p>1、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>2、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num is null</code></pre><p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p><pre><code>select id from t where num=0</code></pre><p>4、尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre><code>select id from t where num=10 or num=20</code></pre><p>可以这样查询：</p><pre><code>select id from t where num=10union allselect id from t where num=20</code></pre><p>5、下面的查询也将导致全表扫描：(不能前置百分号)</p><pre><code>select id from t where name like ‘�c%’</code></pre><p>若要提高效率，可以考虑全文检索。</p><p>6、in 和 not in 也要慎用，否则会导致全表扫描，如：</p><pre><code>select id from t where num in(1,2,3)</code></pre><p>对于连续的数值，能用 between 就不要用 in 了：</p><pre><code>select id from t where num between 1 and 3</code></pre><p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><pre><code>select id from t where num=@num</code></pre><p>可以改为强制查询使用索引：</p><pre><code>select id from t with(index(索引名)) where num=@num</code></pre><p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre><code>select id from t where num/2=100</code></pre><p>应改为:</p><pre><code>select id from t where num=100*2</code></pre><p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre><code>select id from t where substring(name,1,3)=’abc’–name以abc开头的idselect id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id</code></pre><p>应改为:</p><pre><code>select id from t where name like ‘abc%’select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</code></pre><p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p>11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12、不要写一些没有意义的查询，如需要生成一个空表结构：</p><pre><code>select col1,col2 into #t from t where 1=0</code></pre><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><pre><code>create table #t(…)</code></pre><p>13、很多时候用 exists 代替 in 是一个好的选择：</p><pre><code>select num from a where num in(select num from b)</code></pre><p>用下面的语句替换：</p><pre><code>select num from a where exists(select 1 from b where num=a.num)</code></pre><p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p><p>16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>18、尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19、任何地方都不要使用 select <em> from t ，用具体的字段列表代替“</em>”，不要返回用不到的任何字段。</p><p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p><p>22、临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。</p><p>23、在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p><p>24、如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p><p>25、尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p><p>26、使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p><p>27、与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p><p>28、在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p><p>29、尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p><p>30、尽量避免大事务操作，提高系统并发能力。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>定时任务 Crontab命令 详解</title>
    <link href="/2017/01/05/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Crontab%E5%91%BD%E4%BB%A4-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2017/01/05/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-Crontab%E5%91%BD%E4%BB%A4-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>From: <a href="http://www.centoscn.com/CentOS/help/2014/1030/4025.html">http://www.centoscn.com/CentOS/help/2014/1030/4025.html</a></p><p><strong>前言</strong><br>crontab是Unix和Linux用于设置周期性被执行的指令，是互联网很常用的技术，很多任务都会设置在crontab循环执行，如果不使用crontab，那么任务就是常驻程序，这对你的程序要求比较高，一个要求你的程序是24X7小时不宕机，一个是 要求你的调度程序比较可靠，实际工作中，90%的程序都没有必要花这么多时间和精力去解决上面的两个问题的，只需要写好自己的业务逻辑，通过crond这 个工业级程序去调度就行了，crond的可靠性，健壮性，大家应该是毫无疑问的。</p><p><strong>crontab简易入门</strong><br>假设我要设置一个任务，每分钟就要做一个数据同步，这个同步脚本的路径是/home/blue/do/rsyncfile.sh，那么我可以在这么配置，使用blue用户，在终端输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">crontab -e<br><br><span class="hljs-comment"># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span><br><br><span class="hljs-comment">#分 时 日  月 周      |&lt;==============任务的完整命令行</span><br><br> *  *  *  *  *       <span class="hljs-regexp">/home/</span>blue<span class="hljs-regexp">/do/</span>rsyncfile.sh<br></code></pre></td></tr></table></figure><p>默认情况下，任何使用者只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达『 crontab -e 』去编辑自己的例行性命令了！整个过程就如同上面提到的，会进入 vi 的编辑画面， 然后以一个工作一行来编辑，编辑完毕之后输入『 :wq 』储存后离开 vi 就可以了！<br> 假如我们需要修改为每5分钟运行数据同步的脚本，那么同样使用 crontab -e 进入编辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">*<span class="hljs-regexp">/5 * * * *  /</span>home<span class="hljs-regexp">/blue/</span><span class="hljs-keyword">do</span>/rsyncfile.sh<br></code></pre></td></tr></table></figure><p>假如服务器出了问题，有一天的数据没有同步，于是我们就需要补数据了，假设这个补数据的脚本是/home/blue/do /rsyncfile_day.sh,但是白天是高峰期，晚上用户不多，是低峰期，我们补数据会占用大量带宽，尤其是白天，会影响正常业务，所以一般我们 可以让补数据任务在凌晨2点开始跑，那么同样使用crontab -e 进入编辑：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> *  /home/blue/do/rsyncfile_day.sh<br></code></pre></td></tr></table></figure><br>这样，在4月1号凌晨2点0分就会开始启动我们的补数据的脚本了。<br>同步数据，在互联网公司是再平常不过的任务了，这里大家可以看到crontab的魅力所在了，只需要写最简单的业务逻辑，把调度交给crond做，就完成了一个可靠性很高的一项任务了，如果要自己去额外写这种调度程序，不知道要花多少精力才能做到可靠稳定。</p><p><strong>crontab的语法</strong><br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff">crontab [-u username] [-l|-e|-r]<br>选项与参数：<br><span class="hljs-deletion">-u  ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作排程；</span><br><span class="hljs-deletion">-e  ：编辑 crontab 的工作内容</span><br><span class="hljs-deletion">-l  ：查阅 crontab 的工作内容</span><br><span class="hljs-deletion">-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑</span><br></code></pre></td></tr></table></figure><br>查询使用者目前的 crontab 内容:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">crontab -l<br>*<span class="hljs-regexp">/5 * * * *  /</span>home<span class="hljs-regexp">/blue/</span><span class="hljs-keyword">do</span>/rsyncfile.sh<br><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> *  <span class="hljs-regexp">/home/</span>blue<span class="hljs-regexp">/do/</span>rsyncfile_day.sh<br></code></pre></td></tr></table></figure><br>清空使用者目前的 crontab:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">crontab</span> -r<br>crontab -l<br><span class="hljs-literal">no</span> crontab for blue<br></code></pre></td></tr></table></figure><br>如果你想删除当前用户的某一个crontab任务，那么使用crontab -e进入编辑器，再删除对应的任务。</p><p><strong>crontab的限制</strong><br>/etc/cron.allow：将可以使用 crontab 的帐号写入其中，若不在这个文件内的使用者则不可使用 crontab；<br>/etc/cron.deny：将不可以使用 crontab 的帐号写入其中，若未记录到这个文件当中的使用者，就可以使用 crontab 。<br>以优先顺序来说， /etc/cron.allow 比 /etc/cron.deny 要优先， 而判断上面，这两个文件只选择一个来限制而已，因此，建议你只要保留一个即可， 免得影响自己在配置上面的判断！一般来说，系统默认是保留 /etc/cron.deny ，你可以将不想让他运行 crontab 的那个使用者写入 /etc/cron.deny 当中，一个帐号一行！</p><p><strong>/etc/crontab配置文件讲解</strong><br>『 crontab -e 』是针对使用者的 cron 来设计的，如果是『系统的例行性任务』时，就要编辑 /etc/crontab 这个文件。<br>那就是 crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个运行档，但是 /etc/crontab 可是一个『纯文字档』,必须用 root 的身份编辑一下这个文件。<br>首先我们要来看看crontab的文件内容<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>crontab<br></code></pre></td></tr></table></figure><br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># /etc/crontab: system-wide crontab</span><br><span class="hljs-comment"># Unlike any other crontab you don&#x27;t have to run the `crontab&#x27;</span><br><span class="hljs-comment"># command to install the new version when you edit this file</span><br><span class="hljs-comment"># and files in /etc/cron.d. These files also have username fields,</span><br><span class="hljs-comment"># that none of the other crontabs do.</span><br> <br>SHELL=<span class="hljs-regexp">/bin/</span>sh<br><br>PATH=<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sbin:/u</span>sr<span class="hljs-regexp">/local/</span>bin:<span class="hljs-regexp">/sbin:/</span>bin:<span class="hljs-regexp">/usr/</span>sbin:<span class="hljs-regexp">/usr/</span>bin<br> <br><span class="hljs-comment"># m h dom mon dow user  command</span><br><br><span class="hljs-number">17</span> *    * * *   root    cd <span class="hljs-regexp">/ &amp;&amp; run-parts --report /</span>etc/cron.hourly<br><br><span class="hljs-number">25</span> <span class="hljs-number">6</span>    * * *   root    test -x <span class="hljs-regexp">/usr/</span>sbin<span class="hljs-regexp">/anacron || ( cd /</span> &amp;&amp; run-parts --report <span class="hljs-regexp">/etc/</span>cron.daily )<br><br><span class="hljs-number">47</span> <span class="hljs-number">6</span>    * * <span class="hljs-number">7</span>   root    test -x <span class="hljs-regexp">/usr/</span>sbin<span class="hljs-regexp">/anacron || ( cd /</span> &amp;&amp; run-parts --report <span class="hljs-regexp">/etc/</span>cron.weekly )<br><br><span class="hljs-number">52</span> <span class="hljs-number">6</span>    <span class="hljs-number">1</span> * *   root    test -x <span class="hljs-regexp">/usr/</span>sbin<span class="hljs-regexp">/anacron || ( cd /</span> &amp;&amp; run-parts --report <span class="hljs-regexp">/etc/</span>cron.monthly )<br></code></pre></td></tr></table></figure><br>这个文件与将刚刚我们下达 crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">PATH</span>=....：<br></code></pre></td></tr></table></figure><br>这里就是输入运行档的搜寻路径！使用默认的路径配置就已经很足够了！<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">17 </span>* * * *   root    cd / &amp;&amp; <span class="hljs-keyword">run</span>-parts --report /etc/cron.hourly：<br></code></pre></td></tr></table></figure><br>这个 /etc/crontab 里面预配置义出四项工作任务，分别是每小时、每天、每周及每个月分别进行一次的工作！ 但是在五个栏位后面接的并不是命令，而是一个新的栏位，那就是『运行后面那串命令的身份』为何！这与使用者的 crontab -e 不相同。由於使用者自己的 crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份啦！以上表的内容来说，系统默认的例行性工作是以 root 的身份来进行的。<br>那么后面那串命令是什么呢？你可以使用『 which run-parts 』搜寻看看，其实那是一个 bash script 啦！如果你直接进入 /usr/bin/run-parts 去看看， 会发现这支命令会将后面接的『目录』内的所有文件捉出来运行！这也就是说『 如果你想让系统每小时主动帮你运行某个命令，将该命令写成 script，并将该文件放置到 /etc/cron.hourly/ 目录下即可』的意思！<br>现在你知道系统是如何进行他默认的一堆例行性工作排程了吗？如果你下达『 ll /etc/cron.daily 』就可以看到一堆文件， 那些文件就是系统提供的 script ，而这堆 scripts 将会在每天的凌晨 6:25 开始运行！<br>假设你现在要作一个目录，让系统可以每 2 分钟去运行这个目录下的所有可以运行的文件，你可以写下如下的这一行在 /etc/crontab 中：<br><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">*<span class="hljs-regexp">/2 * * * * root run-parts /</span>etc/cron.min<br></code></pre></td></tr></table></figure><br>当然罗， /etc/cron.min 这个目录是需要存在的喔！那如果我需要运行的是一个『程序』而已， 不需要用到一个目录呢？该如何是好？例如在侦测网络流量时，我们希望每五分钟侦测分析一次， 可以这样写：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">*<span class="hljs-regexp">/5 * * * * root /</span>bin<span class="hljs-regexp">/mrtg /</span>etc<span class="hljs-regexp">/mrtg/m</span>rtg.cfg<br></code></pre></td></tr></table></figure><br>如何！创建例行性命令很简单吧！如果你是系统管理员而且你的工作又是系统维护方面的例行任务时， 直接修改 /etc/crontab 这个文件即可喔！又便利，又方便管理呢！</p><p><strong>crontab的原理</strong><br>当使用者使用 crontab 这个命令来创建工作排程之后，该项工作就会被纪录到 /var/spool/cron/ 里面去了，而且是以帐号来作为判别的喔！举例来说， blue 使用 crontab 后， 他的工作会被纪录到 /var/spool/cron/blue 里头去！但请注意，不要使用 vi 直接编辑该文件， 因为可能由于输入语法错误，会导致无法运行 cron 喔！另外， cron 运行的每一项工作都会被纪录到 /var/log/cron 这个登录档中，所以罗，如果你的 Linux 不知道有否被植入木马时，也可以搜寻一下 /var/log/cron 这个登录档呢！<br> crond服务的最低侦测限制是『分钟』，所以『 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 』，因此，只要你编辑完 /etc/crontab 这个文件，并且将他储存之后，那么 cron 的配置就自动的会来运行了！<br>备注：在 Linux 底下的 crontab 会自动的帮我们每分钟重新读取一次 /etc/crontab 的例行工作事项，但是某些原因或者是其他的 Unix 系统中，由于 crontab 是读到内存当中的，所以在你修改完 /etc/crontab 之后，可能并不会马上运行， 这个时候请重新启动 crond 这个服务吧！『/etc/init.d/crond restart』 或 『service crond restart』</p><p><strong>crontab的格式讲解</strong><br>每项工作 (每行) 的格式都是具有六个栏位，这六个栏位的意义为：<br>| 代表意义| 分钟    |小时    |日期（天）    |月份|    周|    命令|<br>| ————- |:————-:| —–:|—–:|—–:|—–:|<br>| 数字范围 |0-59|    0-23|    1-31    |1-12    |0-7    |呀就命令啊|</p><p>比较有趣的是那个『周』喔！周的数字为 0 或 7 时，都代表『星期天』的意思！另外， 还有一些辅助的字符，大概有底下这些：<br>| 特殊字符 | 代表意义|<br>| ————- |:————-:|<br>|<em>(星号)    |代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 </em> ， 就代表著『不论何月、何日的礼拜几的 12:00 都运行后续命令』的意思！<br>|,(逗号)    |代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：0 3,6 <em> </em> <em> command 时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ |<br>|-(减号)    |代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作：20 8-12 </em> <em> </em> command 仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！|<br>|/n(斜线)|那个 n 代表数字，亦即是『每隔 n 单位间隔』的意思，例如每五分钟进行一次，则：<em>/5 </em> <em> </em> <em> command很简单吧！用 </em> 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！|</p><p><strong>周与日月</strong><br>周和日月不是 并 的关系，而是 或 的关系。<br>另一个需要注意的地方在於：『你可以分别以周或者是日月为单位作为循环，但你不可使用「几月几号且为星期几」的模式工作』。 这个意思是说，你不可以这样编写一个工作排程：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">30 </span><span class="hljs-number">12</span> <span class="hljs-number">11</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> root echo <span class="hljs-string">&quot;just test&quot;</span>   &lt;==这是错误的写法<br></code></pre></td></tr></table></figure><br>本来你以为九月十一号且为星期五才会进行这项工作，无奈的是，系统可能会判定每个星期五作一次，或每年的 9 月 11 号分别进行，如此一来与你当初的规划就不一样了～所以罗，得要注意这个地方！上述的写法是不对的！</p><p><strong>CentOS下查看crontab执行历史记录</strong><br>在crontab中添加了定时任务，但发现没有得到期望的结果，因而怀疑是crontab没有执行相应的任务，但怎么定位crontab是否执行呢？<br>这就需要查看crontab的执行历史记录，具体位置如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span><br>tail -100 cron<br></code></pre></td></tr></table></figure><br>在cron文件中即可查阅已经操作过的相关定时任务。</p><p>参考资料:<br><a href="http://vbird.dic.ksu.edu.tw/linux_basic/0430cron_3.php">http://vbird.dic.ksu.edu.tw/linux_basic/0430cron_3.php</a><br><a href="http://baike.baidu.com/view/1229061.htm">http://baike.baidu.com/view/1229061.htm</a> </p><p><strong>一、Crontab 格式说明</strong><br>我们可以用 crontab -e 添加要执行的命令。 命令执行的结果，无论是标准输出还是错误输出，都将以邮件形式发给用户。<br>添加的命令必须以如下格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">* *</span> /command path<br></code></pre></td></tr></table></figure><p>前五个字段可以取整数值，指定何时开始工作，第六个域是字符串，即命令字段，其中包括了crontab调度执行的命令。 各个字段之间用spaces和tabs分割。</p><p>前5个字段分别表示：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">分钟：0<span class="hljs-string">-59</span><br>小时：1<span class="hljs-string">-23</span><br>日期：1<span class="hljs-string">-31</span><br>月份：1<span class="hljs-string">-12</span><br>星期：0<span class="hljs-string">-6</span>（0表示周日）<br></code></pre></td></tr></table></figure><p>还可以用一些特殊符号：<br><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">*： 表示任何时刻<br>,： 表示分割<br>－：表示一个段，如第二端里： <span class="hljs-number">1</span><span class="hljs-number">-5</span>，就表示<span class="hljs-number">1</span>到<span class="hljs-number">5</span>点<br>/n : 表示每个n的单位执行一次，如第二段里，*<span class="hljs-regexp">/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/</span><span class="hljs-number">1.</span> <br></code></pre></td></tr></table></figure><br>一些示例：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">00 </span><span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span> * * * /<span class="hljs-keyword">data</span>/app/scripts/monitor/df.sh<br><span class="hljs-symbol">30 </span><span class="hljs-number">2</span> * * * /<span class="hljs-keyword">data</span>/app/scripts/hotbackup/hot_database_backup.sh<br><span class="hljs-symbol">10 </span><span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span> * * * /<span class="hljs-keyword">data</span>/app/scripts/monitor/check_ind_unusable.sh<br><span class="hljs-symbol">10 </span><span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span> * * * /<span class="hljs-keyword">data</span>/app/scripts/monitor/check_maxfilesize.sh<br><span class="hljs-symbol">10 </span><span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">16</span> * * * /<span class="hljs-keyword">data</span>/app/scripts/monitor/check_objectsize.sh<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">43 21 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">*              21:43 执行</span><br><span class="hljs-emphasis">15 05 *</span> <span class="hljs-emphasis">* *</span>              05:15 执行<br>0 17 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">*               17:00 执行</span><br><span class="hljs-emphasis">0 17 *</span> <span class="hljs-emphasis">* 1               每周一的 17:00 执行</span><br><span class="hljs-emphasis">0,10 17 *</span> <span class="hljs-emphasis">* 0,2,3        每周日,周二,周三的 17:00和 17:10 执行</span><br><span class="hljs-emphasis">0-10 17 1 *</span> <span class="hljs-emphasis">*            毎月1日从 17:00到7:10 毎隔1分钟 执行</span><br><span class="hljs-emphasis">0 0 1,15 *</span> 1             毎月1日和 15日和 一日的 0:00 执行<br>42 4 1 <span class="hljs-emphasis">* *</span>               毎月1日的 4:42分 执行<br>0 21 <span class="hljs-emphasis">* *</span> 1-6             周一到周六 21:00 执行<br>0,10,20,30,40,50 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">* *</span>  每隔10分 执行<br><span class="hljs-emphasis">*/10 *</span> <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">*              每隔10分 执行</span><br><span class="hljs-emphasis">*</span> 1 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">*                 从1:0到1:59 每隔1分钟 执行</span><br><span class="hljs-emphasis">0 1 *</span> <span class="hljs-emphasis">* *</span>                 1:00 执行<br>0 <span class="hljs-emphasis">*/1 *</span> <span class="hljs-emphasis">* *</span>               毎时0分 每隔1小时 执行<br>0 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">* *</span>                 毎时0分 每隔1小时 执行<br>2 8-20/3 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">*            8:02,11:02,14:02,17:02,20:02 执行</span><br><span class="hljs-emphasis">30 5 1,15 *</span> <span class="hljs-emphasis">*             1日 和 15日的 5:30 执行</span><br></code></pre></td></tr></table></figure><p><strong>二、&amp; 后台执行命令</strong><br>当在前台运行某个作业时，终端被该作业占据；而在后台运行作业时，它不会占据终端。可以使用&amp;命令把作业放到后台执行。<br>如：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">30 </span><span class="hljs-number">2</span> * * * /<span class="hljs-keyword">data</span>/app/scripts/hotbackup/hot_database_backup.sh &amp;<br></code></pre></td></tr></table></figure><p>在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。<br>不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：<br>如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">command</span> &gt;out.file <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><p>在这个例子中，2&gt;&amp;1表示所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。</p><p><strong>三、2&gt;&amp;1 含义</strong><br>先看一个例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> * * * /u01/test.sh &gt;/dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><p>这句话的意思就是在后台执行这条命令，并将错误输出2重定向到标准输出1，然后将标准输出1全部放到/dev/null 文件，也就是清空。<br>在这里有有几个数字的意思：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">0表示 键盘输入<br>1表示 标准输出<br>2表示 错误输出<br></code></pre></td></tr></table></figure><p>我们也可以这样写：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> * * *  /u01/test.sh  <span class="hljs-number">1</span>&gt;/u01/<span class="hljs-keyword">out</span>.file  &amp;<br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> * * *  /u01/test.sh  <span class="hljs-number">2</span>&gt;/u01/<span class="hljs-keyword">out</span>.file  &amp;<br><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> * * *  /u01/test.sh  <span class="hljs-number">2</span>&gt;/u01/<span class="hljs-keyword">out</span>.file  <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><p>将tesh.sh 命令输出重定向到out.file, 即输出内容不打印到屏幕上，而是输出到out.file文件中。<br>2&gt;&amp;1 是将错误输出重定向到标准输出。 然后将标准输入重定向到文件out.file。<br>&amp;1 表示的是文件描述1，表示标准输出，如果这里少了&amp;就成了数字1，就表示重定向到文件1。<br>&amp; ：后台执行</p><p>测试：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ls</span> <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span> ： 不会报没有<span class="hljs-number">2</span>文件的错误，但会输出一个空的文件<span class="hljs-number">1</span>；<br><span class="hljs-attribute">ls</span> xxx <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span>： 没有xxx这个文件的错误输出到了<span class="hljs-number">1</span>中；<br><span class="hljs-attribute">ls</span> xxx <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>： 不会生成<span class="hljs-number">1</span>这个文件了，不过错误跑到标准输出了；<br><span class="hljs-attribute">ls</span> xxx &gt;out.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> == ls xxx <span class="hljs-number">1</span>&gt;out.txt <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>：  因为重定向符号&gt;默认是<span class="hljs-number">1</span>，这句就把错误输出和标准输出都传到out.txt 文件中。<br></code></pre></td></tr></table></figure><p><strong>四、2&gt;&amp;1写在后面的原因</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">格式：<span class="hljs-keyword">command</span> &gt; <span class="hljs-keyword">file</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>   ==  <span class="hljs-keyword">command</span>  <span class="hljs-number">1</span>&gt; <span class="hljs-keyword">file</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>首先是command &gt; file将标准输出重定向到file中， 2&gt;&amp;1 是标准错误拷贝了标准输出，也就是同样被重定向到file中，最终结果就是标准输出和错误都被重定向到file中。<br>如果改成： command 2&gt;&amp;1 &gt;file<br>2&gt;&amp;1 标准错误拷贝了标准输出的行为，但此时标准输出还是在终端。&gt;file 后输出才被重定向到file，但标准错误仍然保持在终端。</p><p>延伸阅读：<br>Shell标准输出、标准错误 &gt;/dev/null 2&gt;&amp;1<br>如何让Linux定时任务crond以秒为单位执行(如每隔3秒)</p><p>经验教训：<br>打算在服务器上 每天晚上23:00 定时执行Python脚本，去备份MySql数据库，命令如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">* <span class="hljs-number">23</span> * * * python <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>crontab_python<span class="hljs-regexp">/back_db.py &gt;/</span>dev/<span class="hljs-keyword">null</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>结果呢，每次备份都产生了 60份 备份文件，仔细查看定时任务命令，发现在“分”的位置上，少加了个“0”，因为“*”表示该位置的任何一个值，修改如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">23</span> * * * python /var/www/html/crontab_python/back_db.py &gt;/dev/null <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-number">0</span> <span class="hljs-number">4</span> * * * <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>bin<span class="hljs-regexp">/php /u</span>sr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/www/</span>backup-db<span class="hljs-regexp">/backup_db.php 172.16.8.26 &gt;/</span>dev/<span class="hljs-keyword">null</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br><span class="hljs-number">0</span> <span class="hljs-number">4</span> * * * <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/php/</span>bin<span class="hljs-regexp">/php /u</span>sr<span class="hljs-regexp">/local/</span>nginx<span class="hljs-regexp">/www/</span>backup-db<span class="hljs-regexp">/backup_db.php 172.16.10.151 &gt;/</span>dev/<span class="hljs-keyword">null</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
